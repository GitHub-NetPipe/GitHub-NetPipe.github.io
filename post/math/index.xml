<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss>

  
  <item>
    <title>三角函数公式</title>
    <link>/post/math/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%85%AC%E5%BC%8F/</link>
    
    <summary>三角函数公式</summary>
    
    <content>
      定义 ¶                            诱导公式 ¶奇变偶不变，符号看象限. \su Δ=2k\pi,k\in\mathbb{Z} ¶          \su \sin{(2k\pi&#43;α)}=\sin{α} \su \cos{(2k\pi&#43;α)}=\cos{α} \su \tan{(2k\pi&#43;α)}=\tan{α}               \su \sin{(2k\pi-α)}=-\sin{α} \su \cos{(2k\pi-α)}=\cos{α} \su \tan{(2k\pi-α)}=-\tan{α}         \su Δ=\pi ¶          \su \sin{(\pi&#43;α)}=-\sin{α} \su \cos{(\pi&#43;α)}=\cos{α} \su \tan{(\pi&#43;α)}=\tan{α}               \su \sin{(\pi-α)}=\sin{α} \su \cos{(\pi-α)}=-\cos{α} \su \tan{(\pi-α)}=-\tan{α}         \su Δ=\frac{\pi}{2} ¶          \su \sin{(\frac{\pi}{2}&#43;α)}=\cos{α} \su \cos{(\frac{\pi}{2}&#43;α)}=-\sin{α} \su \tan{(\frac{\pi}{2}&#43;α)}=-\frac{1}{\tan{α}}               \su \sin{(\frac{\pi}{2}-α)}=\cos{α} \su \cos{(\frac{\pi}{2}-α)}=\sin{α} \su \tan{(\frac{\pi}{2}-α)}=\frac{1}{\tan{α}}         \su Δ=\frac{3\pi}{2} ¶          \su \sin{(\frac{3\pi}{2}&#43;α)}=-\cos{α} \su \cos{(\frac{3\pi}{2}&#43;α)}=\sin{α} \su \tan{(\frac{3\pi}{2}&#43;α)}=-\frac{1}{\tan{α}}               \su \sin{(\frac{3\pi}{2}-α)}=-\cos{α} \su \cos{(\frac{3\pi}{2}-α)}=-\sin{α} \su \tan{(\frac{3\pi}{2}-α)}=\frac{1}{\tan{α}}         \su \Pi=-1 ¶ \su \sin{(-α)}=-\sin{α} \su \cos{(-α)}=\cos{α} \su \tan{(-α)}=-\tan{α}  和差角公式 ¶ \su \sin{(α&#43;β)}=\sin{α}\cos{β}&#43;\cos{α}\sin{β} \su \sin{(α-β)}=\sin{α}\cos{β}-\cos{α}\sin{β} \su \cos{(α&#43;β)}=\cos{α}\cos{β}-\sin{α}\sin{β} \su \cos{(α-β)}=\cos{α}\cos{β}&#43;\sin{α}\sin{β} \su \tan{(α&#43;β)}=\frac{\tan{α}&#43;\tan{β}}{1-\tan{α}\tan{β}} \su \tan{(α-β)}=\frac{\tan{α}-\tan{β}}{1&#43;\tan{α}\tan{β}}  二倍角公式 ¶降幂扩角 升幂缩角.   \su \sin{2α}=2\sin{α}\cos{α}   \su \cos{2α}=\cos^2{α}-\sin^2{α}=1-2\sin^2{α}=2\cos^2{α}-1   \su \tan{2α}=\frac{2\tan{α}}{1-\tan^2{α}}   \su 1&#43;\sin{2α}=(\sin{α}&#43;\cos{α})^2   \su 1-\sin{2α}=(\sin{α}-\cos{α})^2   \su 1&#43;\cos{2α}=2\cos^2{α}   \su 1-\cos{2α}=2\sin^2{α}   三倍角公式 ¶ \su \sin{3α}=3\sin{α}-4\sin^3{α} \su \cos{3α}=-3\cos{α}&#43;4\cos^3{α} \su \tan{3α}=\frac{3\tan{α}-\tan^3{α}}{1-3\tan^2{α}}=\tan{α}\tan{(\frac{\pi}{3}&#43;α)}\tan{(\frac{\pi}{3}-α)}  半角公式 ¶ \su \sin{\frac{α}{2}}=±\sqrt{\frac{1-\cos{α}}{2}} \su \cos{\frac{α}{2}}=±\sqrt{\frac{1&#43;\cos{α}}{2}} \su \tan{\frac{α}{2}}=\frac{\sin{α}}{1&#43;\cos{α}}=\frac{1-\cos{α}}{\sin{α}}=±\sqrt{\frac{1-\cos{α}}{1&#43;\cos{α}}}  辅助角公式 ¶其中 \su \sin{φ}=\frac{b}{\sqrt{a^2&#43;b^2}},\quad\cos{φ}=\frac{a}{\sqrt{a^2&#43;b^2}},\quad\tan{φ}=\frac{b}{a}. 万能公式 ¶ \su\sin{α}=\frac{2\tan{\large\frac{α}{2}}}{1&#43;\tan^2{\large\frac{α}{2}}} \su\cos{α}=\frac{1-\tan^2{\large\frac{α}{2}}}{1&#43;\tan^2{\large\frac{α}{2}}} \su\tan{α}=\frac{2\tan{\large\frac{α}{2}}}{1-\tan^2{\large\frac{α}{2}}}  和差化积 ¶ \su \sin{α}&#43;\sin{β}=2\sin{\frac{α&#43;β}{2}}\cos{\frac{α-β}{2}} \su \sin{α}-\sin{β}=2\sin{\frac{α-β}{2}}\cos{\frac{α&#43;β}{2}} \su \cos{α}&#43;\cos{β}=2\cos{\frac{α&#43;β}{2}}\cos{\frac{α-β}{2}} \su \cos{α}-\cos{β}=-2\sin{\frac{α&#43;β}{2}}\sin{\frac{α-β}{2}} \su \tan{α}&#43;\tan{β}=\frac{\sin(α&#43;β)}{\cos{α}\cos{β}} \su \tan{α}-\tan{β}=\frac{\sin(α-β)}{\cos{α}\cos{β}}  积化和差 ¶ \su \sin{α}\cos{β}=\frac{1}{2}[\sin{(α&#43;β)}&#43;\sin{(α-β)}] \su \cos{α}\sin{β}=\frac{1}{2}[\sin{(α&#43;β)}-\sin{(α-β)}] \su \cos{α}\cos{β}=\frac{1}{2}[\cos{(α&#43;β)}&#43;\cos{(α-β)}] \su \sin{α}\sin{β}=-\frac{1}{2}[\cos{(α&#43;β)}-\cos{(α-β)}]  正弦定理 ¶其中 R 为 ΔABC 外接圆半径. 余弦定理 ¶ \su a^2=b^2&#43;c^2-2bc\cos{A} \su b^2=a^2&#43;c^2-2ac\cos{B} \su c^2=a^2&#43;b^2-2ab\cos{B}  三角形面积公式 ¶ \su S_{ΔABC}=\frac{1}{2}\cdot a\cdot h \su S_{ΔABC}=\frac{1}{2}ab\sin{C}=\frac{1}{2}bc\sin{A}=\frac{1}{2}ac\sin{B} \su S_{ΔABC}=\frac{abc}{4R}（R 为 ΔABC 外接圆半径） \su S_{ΔABC}=\frac{a&#43;b&#43;c}{2}\cdot r（r 为 ΔABC 内接圆半径） \su S_{ΔABC}=\sqrt{p(p-a)(p-b)(p-c)},p=\frac{a&#43;b&#43;c}{2}  其它公式 ¶ \su \sin^2{θ}&#43;\cos^2{θ}=1 \su 1&#43;\tan^2{θ}=\frac{1}{\cos^2{θ}} \su 1&#43;\frac{1}{\tan^2{θ}}=\frac{1}{\sin^2{θ}} \su \tan{A}&#43;\tan{B}&#43;\tan{C}=\tan{A}\tan{B}\tan{C}（ΔABC 非 Rt 三角形） \su \sin^2{A}&#43;\sin^2{B}&#43;\sin^2{C}=2&#43;2\cos{A}\cos{B}\cos{C}（在 ΔABC 中） \su \cos^2{A}&#43;\cos^2{B}&#43;\cos^2{C}=1-2\cos{A}\cos{B}\cos{C}（在 ΔABC 中）  
    </content>
  </item>
  

  
  <item>
    <title>斐波那契数列通项</title>
    <link>/post/math/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%80%9A%E9%A1%B9/</link>
    
    <summary>30 秒速解斐波那契数列通项.</summary>
    
    <content>
      已知 a_1=a_2=1,a_{n&#43;2}=a_{n&#43;1}-a_n，求 a_n 的通项. 解： 设 a_{n&#43;2}-ra_{n&#43;1}=s(a_{n&#43;1}-ra_n)， 则 a_{n&#43;2}=(s&#43;r)a_{n&#43;1}-s\cdot ra_n. 对比 a_{n&#43;2}=a_{n&#43;1}-a_n 得 解得 ∴ 数列 \{a_{n&#43;1}-ra_n\} 是以 a_2-ra_1 为首项，s 为公比的等比数列. 两式相减得：   
    </content>
  </item>
  

  
  <item>
    <title>换根 DP</title>
    <link>/post/acm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%8D%A2%E6%A0%B9-dp/</link>
    
    <summary>换根 DP 是基于 树形 DP 的更高效算法.</summary>
    
    <content>
      简介 ¶换根 DP 是基于 树形 DP 的更高效算法. 通常设 f[u] 表示以 u 为树根时的解，进而推出 f[其它节点]. 例 1 ¶给定一棵 n 个点的树，请求出一个节点，使得以其为根时，所有节点的深度之和最大（根节点的深度为 1）. d[u]：（以 1 为树根时）u 的深度. \text{size}[u]：（以 1 为树根时）以 u 为根的子树的节点数. f[u]：以 u 为树根时的节点深度和. 以 1 为根时： 以 3 为根时： 观察发现，原先 3 的子树中（包括 3）节点的深度减少了 1，而其余节点的深度增加了 1. 因此  进一步，设 u 是 v 的父节点，则  先假定 1 为树根，用树形 DP 推出 \text{size} 数组和 d 数组；再用树形 DP 推出 f 数组，并取最大值. 初始条件为 \displaystyle f[1]=\sum d[i]，时间复杂度为 O(n). 
    </content>
  </item>
  

  
  <item>
    <title>矩阵快速幂</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
    
    <summary>矩阵相当于二维数组.</summary>
    
    <content>
      矩阵 ¶矩阵相当于二维数组.   矩阵 A 有 m 行 n 列，称为 m×n 矩阵，简记为 A_{mn}.   矩阵 A 第 i 行 j 列的元素写作 a_{ij}.   单位矩阵 ¶主对角线上的元素都为 1，其余元素为 0 的 n×n 矩阵称为 n 阶单位矩阵，记作 I_n 或 E_n. 矩阵加、减法 ¶矩阵的加减法就是将两个矩阵对应位置上的元素相加减.  矩阵乘法 ¶定义矩阵 A×B=C：   必须满足 A 的列数 = B 的行数.   A_{mr}×B_{rn} 会得到一个 m×n 矩阵.    任意矩阵乘 I_n 都等于它本身. 注意：矩阵乘法满足结合律，不满足交换律. 注意：只有行数 = 列数的矩阵才能进行乘幂运算. 矩阵快速幂 ¶用 快速幂 的思想在 O(n^3\log x) 时间内求 n 阶矩阵的 x 次方. 应用 ¶矩阵快速幂能将 O(n) 的线性递推优化成 O(\log n). 假设有矩阵 A 满足下式： 而 f(1),f(2) 的值已知，就可以推出 f(n) 的值. 其中 A^{n-2} 可以用矩阵快速幂算. 求出 f(n) 的时间复杂度为 O(\log n). 例 1 ¶求 Fibonacci 数列的第 n 项（n\geq 10^{12}）. Fibonacci 数列的递推式： 设矩阵 A=\begin{bmatrix}a_{11}&amp;amp;a_{12}\newline a_{21}&amp;amp;a_{22}\end{bmatrix} 满足下式 于是有 解得 因此 将 f(1)=f(2)=1 代入即可. 注意：矩阵内部的运算可能需要高精度或取模. 例 2 ¶将 例 1 的通项公式改为  求数列的第 n 项（n\geq 10^{12}）. 设 4 阶矩阵 A 满足下式 容易解得 
    </content>
  </item>
  

  
  <item>
    <title>莫比乌斯反演</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 简介 ¶由函数 f 定义一个函数 g：  如果已知 g(n) 的值，就可以用莫比乌斯反演推出 f(n) 的值. 莫比乌斯函数 ¶定义 ¶n 的莫比乌斯函数记为 μ(n)，定义为： 特别地，μ(1)=1. 性质 ¶性质 1 ¶     chevron_right证   设 n 有 k 个质因子 p_1,p_2,\cdots,p_k，则：       由 二项式定理 得：  当且仅当 n=1 时，k=1. 因此：    性质 2 ¶     chevron_right证   根据 性质 1 自证.     chevron_right证   动一动你聪明的小脑瓜.  --&gt;  积性函数 ¶     chevron_right证   读者自证.  模板 ¶基于质数的 线性筛法 求 μ(1)\simμ(n). 狄利克雷卷积 ¶定义 ¶函数 f(x) 和 g(x) 的狄利克雷卷积 h(x) 定义为：  简记为：  性质 ¶  交换律：f* g=g*f.   结合律：(f* g)*h=f *(g *h).   分配律：(f&#43;g)*h=f *h&#43;g *h.   等式的性质：f=g\eq f* h=g*h,h(1)≠0.   单位元：即单位函数 ε，满足 f*ε=f.        值为常数的函数，如 f(n)=C，在狄利克雷卷积中简记为 C.     重要结论 ¶     chevron_right证   由 μ 函数的 性质 1 得：     莫比乌斯反演 ¶形式 1 ¶     chevron_right证   原式可简记为：  由 重要结论 得：  即证.   形式 2 ¶     chevron_right证         即证.  
    </content>
  </item>
  

  
  <item>
    <title>博弈论</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E5%8D%9A%E5%BC%88%E8%AE%BA/</link>
    
    <summary>Under Construction .</summary>
    
    <content>
       Under Construction ...   简介 ¶博弈论主要研究，在一个游戏中，如何最优化多位玩家的策略. 「我预判了你对我预判的预判」 公平组合游戏 ICG ¶  由两名玩家轮流做出行动.   两名玩家的行动规则相同.   不能行动的玩家判负.   NIM 游戏 ¶简介 ¶有 n 堆石子，第 i 堆有 A_i 个石子. 两个玩家轮流取走任意一堆的任意个石子，但不能不取. 取走最后一个石子的玩家胜. NIM 游戏属于公平组合游戏，且不存在平局，只有「先手必胜」和「后手必胜」两种情况. 策略 ¶当且仅当 A_1\oplus A_2\oplus\cdots\oplus A_n≠0 时，先手必胜（\oplus 表示异或）.     chevron_right证      chevron_right引理 1   设 A_1\oplus A_2\oplus\cdots\oplus A_n=k≠0，则：  根据异或的定义，若 k 在二进制下有 {\rm len}(k) 位，则至少有 1 个 A_i 的第 {\rm len}(k) 位为 1，也就必然存在 A_i&amp;gt;A_i\oplus k，因此将 A_i 变为 A_i\oplus k 可以是合法的操作.       chevron_right引理 2   设 A_1\oplus A_2\oplus\cdots\oplus A_n=0，则：  即更改任意一个 A_i 为 A_i&#39;，都会导致异或和不为 0.    结合引理 1，引理 2 可得：   石子被取光时失败（对手取走最后一个石子，获胜），此时异或和为 0.   异或和 ≠0\stackrel{存在一步操作}{\large\xRightarrow{\qquad\qquad}} 异或和 =0.   异或和 =0\stackrel{任意一步操作}{\large\xRightarrow{\qquad\qquad}} 异或和 ≠0.   当 A_1\oplus A_2\oplus\cdots\oplus A_n≠0 时，先手可以使博弈进入一种循环：  轮到后手时，异或和必为 0，即失败的局面只可能轮到后手. 先手必胜. 当 A_1\oplus A_2\oplus\cdots\oplus A_n=0 时，先手失去了主动权，后手可以同样的方法制胜. 此时先手必败.   有向图游戏 ¶简介 ¶在一个有向无环图中，只有一个起点，上面有一枚棋子. 两名玩家轮轮流沿有向边推动棋子，无法移动者判负. 任何公平组合游戏都可以转换为有向图游戏：每个节点表示一个状态，并且向后继状态连有向边. 策略 ¶Mex 运算 ¶设 S% 为非负整数集合. \mex(S) 为不属于 S 的最小非负整数.  SG 函数 ¶状态 x 有 k 个后继状态 y_1,y_2,\cdots,y_k，定义 SG 函数：  单图游戏 ¶设起点为 s，当且仅当 SG(s)≠0 时，先手必胜.     chevron_right证     当棋子无法移动时失败，此时没有后继状态，SG(s)=\mex(\varnothing)=0.   SG(s)≠0\stackrel{存在一步操作}{\large\xRightarrow{\qquad\qquad}}SG(s)=0.   SG(s)=0\stackrel{任意一步操作}{\large\xRightarrow{\qquad\qquad}}SG(s)≠0.   当 SG(s)≠0 时，先手可以通过类似于 NIM 游戏 的方法制胜.  当 SG(s)=0 时，后手必胜.   组合图游戏 ¶对于 n 个有向图游戏组合成的游戏，起点分别为 s_1,s_2,\cdots,s_n. 当且仅当 SG(s_1)\oplus SG(s_2)\oplus\cdots\oplus SG(s_n)≠0 时，先手必胜（\oplus 表示异或）.     chevron_right证   由 单图游戏 可知：   SG(s_i)=0（无法移动每个棋子）时失败，此时异或和 =0.   异或和 ≠0\stackrel{存在一步操作}{\large\xRightarrow{\qquad\qquad}} 异或和 =0.   异或和 =0\stackrel{任意一步操作}{\large\xRightarrow{\qquad\qquad}} 异或和 ≠0.   当 SG(s_1)\oplus SG(s_2)\oplus\cdots\oplus SG(s_n)≠0 时，先手可以通过类似于 NIM 游戏 的方法制胜.    
    </content>
  </item>
  

  
  <item>
    <title>容斥原理</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 简介 ¶容斥原理是一种不重不漏的计数原理. 举个例子，A,B,C 三人竞选扫黄队长：            15 人投给 A   16 人投给 B   17 人投给 C   2 人同时投给 A,B,C                 4 人同时投给 A,B   5 人同时投给 A,C   6 人同时投给 B,C          问共有多少人参与投票. A,B,C 三人的得票情况可以用小学二年级就学过的韦恩图描述：             |A|=15   |B|=16   |C|=17   |A∩B∩C|=2                 |A∩B|=4   |A∩C|=5   |B∩C|=6          问题是求投票人数，即 |A∪B∪C|.  将上述问题推广到普遍情况，就是容斥原理. 公式 ¶并集 ¶对于 n 个集合 S_1,S_2\cdots S_n，|S| 表示集合 S 的元素数，则：      chevron_right证   设 x\in S_{a_1},S_{a_2},\cdots,S_{a_m}，根据公式，\su\left|\bigcup_{i=1}^nS_i\right| 中包含元素 x 的个数为：  根据 二项式定理 有：   每个元素只出现一次，等价于并集，证毕.   交集 ¶对于 n 个集合 S_1,S_2\cdots S_n，已知全集为 U：  其中 \su\left|\bigcup_{i=1}^n\overline{S_i}\right| 套用 并集 的公式计算即可. 多重集的排列数 ¶普通集合中，不允许有相同的元素；多重集中，相同的元素可以出现多次. 设 S=\{n_1\cdot a_1,n_2\cdot a_2,\cdots,n_k\cdot a_k\} 是由 n_1 个 a_1，n_2 个 a_2 &amp;hellip; n_k 个 a_k 组成的多重集，\su n=\sum_{i=1}^kn_i. S 的全排列个数为：      chevron_right证   n 个不同元素的全排列有 n! 种. 若其中有 j 个元素相同，则 n! 种全排列中有部分也是相同的. 单独看这 j 个元素，有 j! 种排列，但它们现在是一样的. 于是总的排列数为：  根据 乘法原理，多重集的全排列个数为：    多重集的组合数 1 ¶设 S=\{∞\cdot a_1,∞\cdot a_2,\cdots,∞\cdot a_k\}，从 S 中任取 λ 个元素的方案数为：      chevron_right证   原问题等价于求以下方程非负整数解的个数：  解的个数用插板法计算： 在 λ 个 1 之间插 k-1 块板，使其分为 k 个区间. 第 i 个区间的和代表 x_i. 这样就构造出了一组解. Waiting&amp;hellip; 需要注意，板插在两端或同一个空隙中是允许的. 最初有 λ&#43;1 个空隙. 插第一块板有 λ&#43;1 种方法，第二块有 λ&#43;2 种，第三块有 λ&#43;3 种 &amp;hellip; 第 k-1 块有 λ&#43;k-1 种. 根据 乘法原理，总的方案数为：  但是插板的顺序与答案无关. 这么算显然会包含一些重复情况： Waiting&amp;hellip; 每一个方案都有 (k-1)! 种不同的插板顺序，故答案为：    多重集的组合数 2 ¶设 S=\{n_1\cdot a_1,n_2\cdot a_2,\cdots,n_k\cdot a_k\}，从 S 中任取 λ(λ≤\sum_in_i) 个元素的方案数为：           chevron_right证   考虑容斥原理： 合法方案数 = 总方案数 - 不合法方案数  总方案数 \su={k&#43;λ-1\choose k-1}，详见 多重集的组合数 1. 于是问题转化为求不合法方案数.   设 T_i 为 a_i 超标的多重集. 先取 n_i&#43;1 个 a_i，再任取 λ-n_i-1 个元素，加入 T_i. 不同 T_i 的数量为 \su{k&#43;λ-n_i-2\choose k-1}.   设 T_{ij} 为 a_i,a_j 超标的多重集. 先取 n_i&#43;1 个 a_i 和 n_j&#43;1 个 a_j，再任取 λ-n_i-n_j-2 个元素，加入 T_{ij}. 不同 T_{ij} 的数量为 \su{k&#43;λ-n_i-n_j-3\choose k-1}.   依次类推，由容斥原理可得，不合法的方案数为：  于是合法的方案数为：    
    </content>
  </item>
  

  
  <item>
    <title>中国剩余定理</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 简介 ¶中国剩余定理最早发现于《孙子算经》中.  有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二. 问物几何？   即求满足下列条件的 x： 它的通解公式为 x=233&#43;105k. 《孙子算经》中只给出了最小正整数解，也就是 k=-2 时的解：x=23. 至于古人是如何发现这个解的，有个网站记载得很详细：百度一下，你就知道. 不过，今天我们只关心中国剩余定理更普遍的应用. 问题 ¶中国剩余定理指关于 x 的同余方程组的解法： 其中 a_1, a_2, \cdots, a_k 两两互质. 解法 ¶设 M=\prod^k_{i=1}m_i，即所有 m 的乘积. 设 \su M_i=\frac{M}{m_i}，即除 m_i 外，其余所有 m 的乘积. 设 M_it_i≡1\pmod{m_i}，t_i 为 M_i 关于模 m_i 的 乘法逆元. 利用刚才设的一大坨东西，我们可以构造出一个解： 计算 x \bmod m_i 时，含 m_i 的项都被模没了，故原式可化简为 (a_iM_it_i) \bmod m_i. 而 t_i 为 M_i 的乘法逆元，因此 x \bmod m_i=a_i. 因此构造出的 x 满足每一个线性同余方程. 模板 ¶
    </content>
  </item>
  

  
  <item>
    <title>卡特兰数列</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E5%88%97/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 简介 ¶卡特兰数列可以是许多看似毫不相关的问题的解.   n 个节点能构成 Cat_n 种不同的二叉树.   n 个左括号和 n 个右括号组成的合法序列有 Cat_n 种.   n 个元素的进栈顺序为 1,2,\cdots,n，合法的出栈顺序有 Cat_n 种.   在圆上选择 2n 个点成对连接，使得 n 条线段不相交的方法数为 Cat_n.   通过若干条互不相交的对角线,把凸 n 边形拆分成若干个三角形的方案数为 Cat_{n-2}.   在平面直角坐标系上，每一步只能向上或向右走 1 个单位，从 (0,0) 走到 (n,n) 且不接触直线 y=x 的路径数量为 2Cat_n-1.   通项公式 ¶ 递推公式 ¶ 附表 ¶   Cat_0 Cat_1 Cat_2 Cat_3 Cat_4 Cat_5 Cat_6 Cat_7 Cat_8 \cdots     1     1     2     5     14    42    132   429   1430  \cdots    
    </content>
  </item>
  

  
  <item>
    <title>卢卡斯定理</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 简介 ¶Lucas 定理用于求解大组合数对质数 p 取模：  适用范围是 p≤10^6. 证明 ¶ Under Construction ...   解法 ¶对于 n,m≤10^6 的组合数 \su{n\choose m}，可以直接代入 公式，并使用 乘法逆元 将除法转为乘法.  对于更大的组合数，套用 Lucas 定理.  其中 \su{n \bmod p\choose m \bmod p} 可以直接算，\su{\lfloor n/p\rfloor\choose\lfloor m/p\rfloor} 需要递归求解. 算上预处理，总时间复杂度为 O(p&#43;\log_p{n}). 预处理 ¶  fac[i]=i!\bmod p，线性递推：    inv[i]=(i!)^{-1}，参考 线性求逆元：     模板 ¶
    </content>
  </item>
  

  
  <item>
    <title>二项式定理</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 简介 ¶ 证明 ¶使用数学归纳法. 设 n=k 时二项式定理成立，考察 n=k&#43;1 时是否也成立：       ∴\,二项式定理满足递推成立关系： n=k 时成立 \Longrightarrow n=k&#43;1 时成立  ∵n=1 时 \su(a&#43;b)^1=\sum_{i=0}^1\binom{n}{i}a^{n-i}b^i=a&#43;b 成立， ∴\,二项式定理在 n=1 之后的任何整数都成立. 
    </content>
  </item>
  

  
  <item>
    <title>组合数学</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 简介 ¶  排列：从 n 个元素中取出 m 个，按一定顺序排列.   组合：从 n 个元素中取出 m 个，不计排列顺序.   加法原理 ¶做一件事情有 n 种方式，第 i 种方式有 a_i 种方法，则做成这件事共有 \sum_{i=1}^na_i 种方法.     chevron_right例子   从 A 地到 B 地有爬行、骑车、飞行三种方式，可以任选一个. 而爬行、骑车、飞行分别有 a_1,a_2,a_3 种方法，那么 A→B 共有 a_1&#43;a_2&#43;a_3 种方法.  乘法原理 ¶做一件事情有 n 个步骤，第 i 个步骤有 a_i 种方法，则做成这件事共有 \prod_{i=1}^na_i 种方法.     chevron_right例子   从 A 地到 B 地必须先爬行到车站，再骑车到机场，最后飞行到北京，而爬行、骑车、飞行分别有 a_1,a_2,a_3 种方法，那么 A→B 共有 a_1\cdot a_2\cdot a_3 种方法.  排列数 ¶从 n 个元素中取出 m 个，按一定顺序排列的方案数，用符号 A_n^m 表示.  n=m 时的排列称为全排列，A_n^n=n!. 组合数 ¶从 n 个元素中取出 m 个，不计排列顺序的方案数，用符号 C_n^m 或 \su{n\choose m} 表示.   特别地，当 m&amp;gt;n 时，A_n^m=C_n^m=0   互补性 ¶     chevron_right证     帕斯卡法则 ¶     chevron_right证     
    </content>
  </item>
  

  
  <item>
    <title>欧拉函数</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 定义 ¶n 的欧拉函数为 [1,n] 中与 n 互质的数的个数，记为 \varphi(n). 特别地，\varphi(1)=1. 性质 ¶质数的欧拉函数 ¶p 为质数，则 \varphi(p)=p-1.     chevron_right证   p 与 [1,p-1] 中的每个数互质.  p^k 的欧拉函数 ¶p 为质数，n=p^k，则 \varphi(n)=p^k-p^{k-1}.     chevron_right证   在 [1,n] 中，只有 p 的倍数不与 n=p^k 互质. ∵\;[1,n] 中 p 的倍数有 \dfrac{n}{p}=\dfrac{p^k}{p}=p^{k-1} 个， ∴\varphi(n)=n-p^{k-1}=p^k-p^{k-1}.   通项公式 ¶n 有 m 个质因子 p_1∼p_m，则 \su\varphi(n)=n\prod_{i=1}^{m}(1-\frac{1}{p_i}).     chevron_right证   若 n 有质因子 p，则 p 的倍数不与 n 互质. [1,n] 中 p 的倍数有 \dfrac{n}{p} 个，则剩下的 n-\dfrac{n}{p}=n\cdot(1-\dfrac{1}{p}) 个数不是 p 的倍数. 也就是说，这 n 个数中，非 p 的倍数占比为 1-\dfrac{1}{p}. 根据定义，[1,n] 中有 \varphi(n) 个数不是 p_1∼p_m 的倍数（即与 n 互质）. 由乘法原理得：    积性函数 ¶n,m 互质，则 \varphi(nm)=\varphi(n)\cdot \varphi(m).     chevron_right证   设 n 有 x 个质因子 p_1\sim p_x， 设 m 有 y 个质因子 q_1\sim q_y， ∵n,m 互质，∴n,m 的质因子互不相同. ∴nm 有 x&#43;y 个质因子 p_1\sim p_x,q_1\sim q_y. 由 \varphi 函数的通项公式可得： 即证.   定理 ¶欧拉定理 ¶若 a,n 互质，则 a^{\footnotesize\varphi(n)}≡1\pmod{n}.     chevron_right证   设 C=\{C_1,C_2,\cdots,C_{\varphi(n)}\} 为模 n 的 简化剩余系. 设 aC=\{aC_1,aC_2,\cdots,aC_{\varphi(n)}\}，即 C 中的每个元素乘 a.    chevron_right引理 1   由 剩余系 的定义得：  ∵a,n 互质，由同余的 同乘性 可知：  ∴aC 为模 n 的剩余系.       chevron_right引理 2   ∵a,n 互质，根据 欧几里得算法 有：  ∴a \bmod n 也与 n 互质. 根据 简化剩余系 的定义可知：  ∵\;简化剩余系满足 乘法封闭 性质，所以： ∴aC_i \bmod n 与 n 互质，即 aC 中的任意元素模 n 后与 n 互质.    结合引理 1、引理 2 可知 aC 也为 n 的简化剩余系. 显然，C 的所有元素之积和 aC 的所有元素之积模 n 同余，即：    ∵C 中的所有元素模 n 后与 n 互质，所以：  ∴a^{\varphi(n)}-1≡0\pmod{n}，即 a^{\varphi(n)}≡1\pmod{n}.   费马小定理 ¶若 p 为质数，则 a^{p-1}≡a\pmod{p}.     chevron_right证   当 p\mid a 时，费马小定理显然成立，故只需讨论 p\nmid a 的情况. 当 p\nmid a 时，∵p 是质数 ∴a,p 没有公因数（即 a,p 互质）. 根据 欧拉定理 有：  ∵p 为质数，由 性质 可知 \varphi(p)=p-1. 代入上式：  即证.     扩展欧拉定理 ¶若 a,n 互质，则对于任意 b，有 a^b≡a^{b \bmod \varphi(n)}\pmod{n}.     chevron_right证   设 b \bmod \varphi(n)=q，则 b 可以表示为 k\cdot \varphi(n)&#43;q. 代入 a^b 得：  根据 欧拉定理，当 a,n 互质时，有：  由同余的 同幂性、同乘性 可知：    即 a^b≡a^{b \bmod \varphi(n)}\pmod{n}.   模板 ¶欧拉函数 ¶线性欧拉算法 ¶ 求 1\sim n 的欧拉函数.   对质数的 线性筛法 加以改造.   若 i 为质数，则 \varphi(i)=i-1.   利用 i 和 prime_j 生成合数时，利用 积性函数 这一性质：    时间复杂度为 O(n). 
    </content>
  </item>
  

  
  <item>
    <title>乘法逆元</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 定义 ¶若 a\cdot b≡1\pmod{p}，则 b 为 a 在模 p 意义下的逆元，记作 a^{-1} 或 inv(a).  乘法逆元能够很好地将模运算中的除法转为乘法：   在模运算中，a^{-1} 是整数，并不是 a 的 -1 次方.   解法 ¶对于整数 x，可以求解关于 x^{-1} 的 线性同余方程 x\cdot x^{-1}≡1 \ (\bmod \ p)，其中 x 为已知常数. 质数的逆元 ¶当 p 为质数时，由 费马小定理 得： ∴p^{-1}=a^{p-2} \bmod p. 其中 a^{p-2} 可用 快速幂 求解. 线性求逆元 ¶ 求 1\sim n 在模 p 意义下的逆元.   假设已经求出了 1\sim i-1 的乘法逆元. 设 \su m=p \bmod i=p-\Big\lfloor\frac{p}{i}\Big\rfloor\cdot i，则有：  两边同乘 m^{-1}i^{-1}：  由于 m=p \bmod i≤i-1，所以 m^{-1} 已知. 于是得到 i^{-1} 的表达式：  
    </content>
  </item>
  

  
  <item>
    <title>线性同余方程</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 简介 ¶形如 ax≡c\pmod{b} 的方程称为线性同余方程. 特殊解 ¶ax≡c\pmod{b}\eq ax&#43;by=c. 由 裴蜀定理 可知：当且仅当 gcd(a,b)\mid c 时有整数解. 先用 扩展欧几里得算法 求出一组 x_0,y_0，使得：  两边同时乘 \su\frac{c}{gcd(a,b)}：  于是找到方程 ax&#43;by=c 的一组特殊解： 
    </content>
  </item>
  

  
  <item>
    <title>欧几里得算法</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</link>
    
    <summary>$a$ 和 $b$ 的最大公因数记作 $gcd(a,b)$，简记为 $(a,b)$.</summary>
    
    <content>
      最大公因数 ¶a 和 b 的最大公因数记作 gcd(a,b)，简记为 (a,b). 设 a &amp;gt; b，d 是 a,b 的任意一个公因数，则： ∴a 和 b 的所有公因数，同时也是 b 和 a \bmod b 的公因数，因此它们的最大公因数也相等.  使用递归求解. 递归进行到 b=0 时，a 即为 gcd(a,b). 时间复杂度为 O(log{(a&#43;b)}). 最小公倍数 ¶a 和 b 的最小公倍数记作 lcm(a,b)，简记为 [a,b]. 设 gcd(a,b)=d，则 a=k_1d,b=k_2d，所以：  时间复杂度为 O(log{(a&#43;b)}). 扩展欧几里得算法 ¶扩展欧几里得算法用于求方程 ax&#43;by=gcd(a,b) 关于 x,y 的解，其中 a,b 是常数. 设 ax_1&#43;by_1=gcd(a,b), 设 bx_2&#43;(a \bmod b)y_2=gcd(b,a \bmod b), 由 gcd(a,b)=gcd(b,a \bmod b) 可知：  自此，我们可以通过 bx_2&#43;(a \bmod b)\,y_2=gcd(a,b) 的解推出 ax&#43;by=gcd(b,a \bmod b) 的解. 原问题的求解就可以放进递归里. 那么这个递归的边界条件是什么呢？ 当递归到 b=0 时，a=gcd(a,b)，此时一定有一组解 \left\{\begin{aligned}x&amp;amp;=1\\y&amp;amp;=0\end{aligned}\right. 满足 ax&#43;by=gcd(a,b). 这个特殊解可以作为递归的边界条件. 
    </content>
  </item>
  

  
  <item>
    <title>贝祖定理</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 简介 ¶对于任意 a,b，ax&#43;by=c\eq gcd(a,b)\mid c. 证明 ¶设 gcd(a,b)=d，则： 即 gcd(a,b)\mid c. 
    </content>
  </item>
  

  
  <item>
    <title>快速幂</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
    
    <summary>如何快速求 $a^b$（$a,b\in\mathbb{Z}$）？</summary>
    
    <content>
      快速幂 ¶如何快速求 a^b（a,b\in\mathbb{Z}）？ 递归写法 ¶根据乘方公式 a^{m&#43;n}=a^m\cdot a^n，有：    边界条件 时间复杂度     a^0=1 O(\log{b})    递推写法 ¶若 b 在二进制下的第 k_1,k_2,k_3,\cdots 位为 1，则 b=2^{k_1}&#43;2^{k_2}&#43;2^{k_3}&#43;\cdots(k_i≤\log{b}). 举个例子，(14)_{10}=(1011)_2，二进制下 14 的第 0,1,3 位都为 1，那么 14=2^0&#43;2^1&#43;2^3. 将 b=2^{k_1}&#43;2^{k_2}&#43;2^{k_3}&#43;\cdots 代入 a^b： 扫描 b 的每个二进制位，如果第 k 位是 1，则将答案乘上 a^{2^k}. 时间复杂度为 O(\log{b}). 
    </content>
  </item>
  

  
  <item>
    <title>数学期望</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/</link>
    
    <summary>数学期望 $=($每种结果 $×$ 该结果的概率$)$ 的总和，简称期望.</summary>
    
    <content>
      定义 ¶数学期望 =(每种结果 × 该结果的概率) 的总和，简称期望. 若随机数 x 有 n 个可能的值，取值为 x_i 的概率为 P(x_i)，则它的期望为：  数学期望可以理解为加权平均数. 性质 ¶设 A,B,C 为常数，X,Y 为随机变量，则：   E(C)=C.   E(CX)=CE(X).   E(X&#43;Y)=E(X)&#43;E(Y).   当 X,Y 互相独立时，E(XY)=E(X)E(Y).   当 X,Y 互相独立时，E(AX&#43;BY)=AE(X)&#43;BE(Y).    X 和 Y 相互独立，指 P(X) 和 P(Y) 不相互影响.   
    </content>
  </item>
  

  
  <item>
    <title>同余</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E5%90%8C%E4%BD%99/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 定义 ¶若 a \bmod m=b \bmod m，则 a 和 b 模 m 同余，记作 a≡b\pmod{m}.  性质 ¶  自反性：a≡a\pmod{m}.   对称性：a≡b\pmod{m}\eq b≡a\pmod{m}.   传递性：\left\{\begin{aligned}a&amp;amp;≡b \ (\bmod \ m)\\b&amp;amp;≡c \ (\bmod \ m)\end{aligned}\right.\eq a≡c\pmod{m}.   同加性：a≡b\pmod{m}\eq a&#43;c≡b&#43;c\pmod{m}.   同乘性：a≡b\pmod{m}\eq ac≡bc\pmod{m}.   同幂性：a≡b\pmod{m}\eq a^n≡b^n\pmod{m}.    同余不满足同除性. 当 a≡b \ (\bmod \ m) 时不一定有 \su\frac{a}{n}≡\frac{b}{n} \ (\bmod \ m).   同余类 ¶集合 A 是模 m 的同余类，当且仅当：  A 中的所有元素模 m 都等于同一个值 a.   a 称为该同余类的代表元. 模 m 的同余类有 m 个，其代表元分别为 0,1,2,\cdots,m-1. 剩余系 ¶集合 A 是模 m 的剩余系，当且仅当：  A 中的元素模 m 互不相同.   完全剩余系 ¶模 m 的完全剩余系有 m 个元素，是元素最多的剩余系. 简化剩余系 ¶模 m 的简化剩余系有 \varphi(m) 个元素，每个元素模 m 后都与 m 互质. 乘法封闭 ¶从模 m 的简化剩余系中任取两个数 a, b，则 ab \bmod m 也在模 m 的简化剩余系中.     chevron_right证   设 a,b 属于模 m 的简化剩余系，则 a \bmod m,b \bmod m 与 m 互质，(a \bmod m)(b \bmod m) 也与 m 互质. 根据 欧几里得算法 有：       ∴ab \bmod m 与 m 互质，也属于模 m 的简化剩余系.   
    </content>
  </item>
  

  
  <item>
    <title>因数</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E5%9B%A0%E6%95%B0/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 定义 ¶a÷b 的余数为 c，则称 a 模 b 等于 c，记作 a \bmod b=c. 若 n \bmod d=0，则 d 是 n 的因数，记为 d\mid n. 算数基本定理 ¶任意正整数 n 都能唯一分解为有限个质数的乘积：  分解质因数 ¶试除法 ¶ 将 n 分解成 算数基本定理 中的形式.   判断 n 能否整除 [2,\sqrt{n}] 中的所有整数 i，如果能，则从 n 中除掉所有的因子 i，并记录因子 i 的个数. 时间复杂度为 O(\sqrt n). 倍数法 ¶ 求 [1,n] 中所有整数的因数集合.   用 试除法 很容易超时，此时考虑倍数法： i 一定是 i 的倍数的因数. 枚举 [1,n] 中每个数的倍数即可. 时间复杂度为 O(n\log{n}). 
    </content>
  </item>
  

  
  <item>
    <title>质数</title>
    <link>/post/acm/%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0/</link>
    
    <summary>注意：若无特殊说明，本章涉及的变量皆为正整数.</summary>
    
    <content>
      注意：若无特殊说明，本章涉及的变量皆为正整数. 定义 ¶  质数不能被 1 和它本身之外的任何自然数整除，合数则相反. 1 既不是质数，也不是合数.   \pi(n) 表示 n 以内的质数个数，\su\pi(n)≈\frac{n}{\ln{n}}.   第 n 个质数 p(n)≈n\ln{n}.   质数的判定 ¶若 n 为合数，则 n 一定有因数 ≤\sqrt{n}. 判断 n 能否整除 [2,\sqrt n] 中的整数，对于 n=0 或 1 需要特判. 时间复杂度为 O(\sqrt n).     chevron_right证   设合数 n 的任意因数 a_i 满足 a_i&amp;gt;\sqrt{n}，则 \su\frac{n}{a_i}&amp;lt;\frac{n}{\sqrt{n}}=\sqrt{n}. 又 \su∵\frac{n}{a_i} 也是 n 的因数，∴\;假设不成立. 故任意合数 n 一定有因数 ≤\sqrt{n}.   质数筛法 ¶ 求 n 以内的所有质数.   暴力算法 ¶对 [2,n] 中的所有整数进行一次判断. 时间复杂度为 O(n\sqrt{n}). 埃氏筛法 ¶  标记 2 的倍数 4,6,8,\cdots   标记 3 的倍数 6,9,12,\cdots   4 被标记过，不用标记 4 的倍数.   标记 5 的倍数 10,15,20,\cdots \cdots   最后，没被标记的数 k 不能被 [2,k-1] 中的任意整数整除，是质数. 埃氏筛法从小到大枚举 x，并标记它的倍数，这导致每个合数最先被它的最小质因子标记. 标记 i 的倍数时，小于 i^2 的 i 倍数都被更小的质因子标记过，因此只需从 i^2 开始标记. 时间复杂度为 O(n\log{\log{n}}). 线性筛法 ¶在埃氏筛法中，有些合数会被重复标记，如 12 会在 i=2 和 i=3 时被分别标记. 如果每个合数只被标记一次，时间复杂度就可以降到人见人爱的 O(n). 现在我们来一步步实现这个跃迁. 首先，质数的倍数必为合数. 如果已知 i&amp;gt;2 和 i 以内的所有质数，就可以利用他们生成合数. 在最外层补上 i=2→n 的循环. 和 埃氏筛法 类似，由于我们从小到大枚举质数，并标记它的倍数，这导致每个合数最先被其最小质因子标记. 若 i 能整除 prime_j，则 i 可以表示为 k\cdot prime_j. 对于下一个质数 prime_{j&#43;1} 而言，它和 i 可以生成合数：  此合数的最小质因子是 prime_j，它在将来会被一个比 i 大的数乘 prime_j 生成. 此时就不用标记了，可以退出循环. 每个合数只会被自己的最小质因子标记一次，时间复杂度为 O(n). 
    </content>
  </item>
  

  
  <item>
    <title>差分约束系统</title>
    <link>/post/acm/%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/</link>
    
    <summary>给定 $n$ 个变量 $X_1,X_2,X_3,\cdots,X_n$ 之间的大小关系：</summary>
    
    <content>
      简介 ¶给定 n 个变量 X_1,X_2,X_3,\cdots,X_n 之间的大小关系： 求一组满足所有条件的 X_1\cdots X_n 的解. 这些形如 X_j - X_i ≤ C（C 为常数）的不等式共同组成了「差分约束系统」. 原理 ¶SPFA 算法 的核心在于 松弛操作. 节点 s 作为起点，dis[u] 为 s→u 的路径长.如果 dis[j] &amp;gt; dis[i] &#43; g[i,j]，那么就可以用 i 节点松弛 dis[j]：令 dis[j] = dis[i] &#43; g[i,j].  也就是说，当 SPFA 程序结束时，图中任意两个节点 i,j 满足 dis[j] ≤ dis[i] &#43; g[i,j]. 所以 SPFA 和差分约束系统有什么关系呢？事实上，差分约束系统的不等式可以变形为：  和 dis[j] ≤ dis[i] &#43; g[i,j] 是不是非常相似？ 于是，我们可以将 dis[i] 看作未知变量 X_i，i→j 的边（即 g[i,j]）看作常数 C.  然后在图上跑一遍 SPFA，程序结束后，X_1\sim X_n 就能满足差分约束系统中的所有不等式. 模板 ¶
    </content>
  </item>
  

  
  <item>
    <title>强连通分量</title>
    <link>/post/acm/%E5%9B%BE%E8%AE%BA/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</link>
    
    <summary>在有向图 $G$ 中，如果同时存在 $u→v$ 和 $v→u$ 的路径，那么称 $u$ 和 $v$ 强连通.</summary>
    
    <content>
      简介 ¶强连通 ¶在有向图 G 中，如果同时存在 u→v 和 v→u 的路径，那么称 u 和 v 强连通.  强连通图 ¶如果有向图 G 的任意两个节点都强连通，那么称 G 是强连通图.  强连通分量 ¶如果图 G 的子图是强连通图，那么该子图称作 G 的强连通分量.  本章介绍求强连通分量的三种算法. Tarjan 算法 ¶图的结构 ¶Tarjan 算法基于对图的 深度优先遍历（DFS），并且将图近似地看成一棵 树.因此，这棵树中会不可避免地出现一些奇怪的边.    前向边：与普通边方向一致，但跨越多个节点.   返祖边：与普通边方向相反，从子孙指向祖先.   横向边：边的两个端点居于树的同一深度.   时间戳 ¶DFS 遍历一张图时，按访问顺序给节点打标记.u 是第 i 个被访问的节点，记作 dfn[u]=i.这个标记叫做「时间戳」.在图中，时间戳标记在节点的右上方.     u 1 2 3 4 5 6     dfn[u] 1 2 5 3 4 6    追溯值 ¶Tarjan 算法还引入了「追溯值」：low[u]，定义为以下节点时间戳的最小值：   以 u 为根的子树中的所有节点.   从这棵子树的任意节点出发，经过 1 条前向边、返祖边或横向边，能到达的节点.   以 low[2] 为例，其子树中有 2,4,5 号节点，还可以通过一条返祖边到达 1 号节点.low[2] 为这些节点时间戳的最小值，也就是 1.     u 1 2 3 4 5 6     low[u] 1 1 5 1 4 6    基本原理 ¶Tarjan 算法是如何利用 dfn 和 low 来求强连通分量的呢？   首先，强连通分量中必然存在环，也就必然存在返祖边.   如果节点 u 满足 dfn[u]=low[u]，存在两种情况：   如果 u 没有出边，则 u 独自为一个强连通分量.   否则 u 的子树中必有一条返祖边指向 u 本身，此处必存在多节点的强连通分量.     要想具体地确定哪些节点是强连通分量，还得借助 栈.具体看以下样例.         1        dfn[1]=low[1]=1.     u 1 2 3 4 5 6     dfn[u] 1        low[u] 1               2        dfn[2]=low[2]=1.     u 1 2 3 4 5 6     dfn[u] 1 2       low[u] 1 2              3        dfn[4]=low[4]=3.节点 4 有一条返祖边指向 1，故更新 low[4]=low[1]=1.     u 1 2 3 4 5 6     dfn[u] 1 2  3     low[u] 1 2  \textcolor{red}{1}            4        回溯至节点 2，更新 low[2]=\min(low[2],low[4])=1.     u 1 2 3 4 5 6     dfn[u] 1 2  3     low[u] 1 \textcolor{red}{1}  1            5        dfn[5]=low[5]=4.节点 5 没有出边和子树，单独一个节点构成强连通分量.移除栈顶的 5.     u 1 2 3 4 5 6     dfn[u] 1 2  3 \textcolor{red}{4}    low[u] 1 1  1 \textcolor{red}{4}           6        回溯至节点 2，low[2]=\min(low[2],low[5])=1.     u 1 2 3 4 5 6     dfn[u] 1 2  3 4    low[u] 1 1  1 4           7        回溯至节点 1，low[1]=\min(low[1],low[2])=1.此时 low[1]=dfn[1]，栈顶的红色部分同属一个强连通分量.将其从栈中删除.     u 1 2 3 4 5 6     dfn[u] \textcolor{red}{1} 2  3 4    low[u] \textcolor{red}{1} 1  1 4           ...             时间复杂度为 O(n&#43;m)（n 为点数，m 为边数）. Kosaraju 算法 ¶Kosaraju 的核心思想可以总结为两点：   强连通分量反过来还是强连通分量.   把强连通分量反一半过来会得到两条共起点、终点的路径.   第一次正向遍历，第二次反向遍历，若出现共起点、终点的两条路径，则此处必有强连通分量. Garbow 算法 ¶ 未完待续 \cdots \ \cdots   
    </content>
  </item>
  

  
  <item>
    <title>二叉堆</title>
    <link>/post/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E5%A0%86/</link>
    
    <summary>二叉堆（Binary Heap） 是一种基于完全二叉树的数据结构.</summary>
    
    <content>
      简介 ¶二叉堆（Binary Heap） 是一种基于完全二叉树的数据结构.   小根堆：任意节点 ≥ 其父节点，根节点最小.   大根堆：任意节点 ≤ 其父节点，根节点最大.    本篇以小根堆为例，介绍二叉堆的实现方式. 构造 ¶按照从上到下，从左到右的顺序给节点编号.  该二叉堆具有以下性质：   1 号节点是根节点.   u 号的父节点为 \su\frac{u}{2}（向下取整）.   u 号的左子节点为 2u，右子节点为 2u&#43;1.   二叉堆的任意一条支路都按照升序排序.    使用数组保存二叉堆. 插入 ¶如何往小根堆中插入元素 2？   在堆底新建节点，值为 2；   对新节点所在支路进行排序.重复执行以下步骤：  若新节点 &amp;lt; 其父节点，则交换它们的位置，否则跳出循环.            1              2              3             时间复杂度为 O(n\log{n}). 移除 ¶将小根堆的根节点移除，如何调整使其仍为小根堆？    把堆底最后一个元素移到根节点；   从根节点 u=1 开始，重复执行以下步骤：   比较 u 的两个子节点，取最小的一个，记为 v；   若 t[u]&amp;gt;t[v]，交换节点 u 和 v 的位置，并使 u=v，否则跳出循环.             1              2              3             模板 ¶
    </content>
  </item>
  

  
  <item>
    <title>最短路径</title>
    <link>/post/acm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link>
    
    <summary>现在给你 $n$ 个节点（编号为 $1\sim n$）和它们之间的边长，求任意两个节点之间的最短路径.</summary>
    
    <content>
      简介 ¶现在给你 n 个节点（编号为 1\sim n）和它们之间的边长，求任意两个节点之间的最短路径. 松弛操作 ¶使用 邻接矩阵 g 存图.如果 g[i,k] &#43; g[k,j] &amp;lt; g[i,j]，则路径 i→k→j 比原先 i→j 的路径更短，那么就令 g[i,j] = g[i,k] &#43; g[k,j].这就是松弛操作.  Floyed 算法 ¶一开始，我们将所有节点全部拨到图外面，然后按 1 号到 n 号顺序依次往图中加入节点. g[k,i,j]：当图中已经加入了 1 \sim k 号节点时，从节点 i 到 j 的最短路径. 当节点 k 被加入图中时，枚举节点 i 和 j，利用新加入的 k 对路径 i-j 进行 松弛操作：   若路径 i-j 不经过节点 k，则 g[k,i,j] = g[k - 1,i,j]；   若路径 i-j 经过节点 k，则 g[k,i,j] = g[k - 1,i,k] &#43; g[k - 1,k,j].    实际上，g 数组的第一维不影响结果，可以摘掉. Floyed 算法适用于任何图，但图中必须存在最短路.时间复杂度为 O(n^3). Bellman-Ford 算法 ¶Bellman-Ford 算法是基于 Floyed 算法的优化版本，但是只能处理单源最短路径：每跑一次 Bellman-Ford 算法，都需要给定源节点 s，并且只能求得 s 到其它节点的最短路. Floyed 枚举节点的效率太低，于是 Bellman-Ford 改为枚举边. n 个节点 m 条边的图中，如果存在最短路径，则最短路径所包含的边数 ≤ n-1.故每条路最多被松弛 n-1 次.dis[i] 表示 s→i 的最短路长度，初始时要设为无穷大. 时间复杂度为 O(nm). 判断负权回路 ¶若图中存在长度为负数的 回路，则此回路称为 负权回路（负环）.有负权回路的图不存在最短路. 使用 Bellman-Ford 算法时，如果一条路径被松弛了 n 次及以上，则一定存在负权回路. SPFA 算法 ¶SPFA 算法是 Bellman-Ford 算法的队列优化版本.只有上一次被松弛的节点的出边，才有可能引起下一次的松弛操作.每次取队首节点，对其出边进行松弛，将松弛到的节点加入队列.时间复杂度为 O(kn).平均情况下，k 为 (1,2) 中的常数. 判断负权回路 ¶Dijkstra 算法 ¶从节点 s 出发.首先把所有节点分成两个集合：已确定最短路长度的，和未确定的.一开始只有 s 在第一个集合，且 dis[s] = 0,dis[ 除 s 以外的其他节点 ]=∞. 重复以下操作直到第二个集合中没有节点：   松弛刚加入第一个集合的节点的所有出边.   从第二个集合中，选取 dis 值最小的节点，加入第一个集合.   只能处理单源最短路径，不能处理负权路径.时间复杂度为 O(n^2). 
    </content>
  </item>
  

  
  <item>
    <title>并查集</title>
    <link>/post/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
    
    <summary>并查集支持以下操作：</summary>
    
    <content>
      简介 ¶并查集支持以下操作：   往一个集合中加入元素；   查询两个元素是否在同一集合；   合并两个集合.   问题 ¶\{a,b\}，\{e,c\}，\{e,d\} 分别在同一个集合，则共有几个集合？b 和 d 是否同集？ 构造 ¶把同集的两节点相连，则集合数 = 连通图数. 若两节点连通，则它们同集. 并查集在每个集合中选取一个代表元素作为根节点，构造树型结构. 如图，a,e 分别为两集合的代表元素. fa[i] 为节点 i 的父节点编号.上图中 fa[b]=a，fa[c]=e，fa[d]=e. 根节点的 fa 值都设为 0，fa[a]=0，fa[e]=0. 查询代表元素 ¶集合的代表元素就是并查集中的根节点.若节点 x 没有父节点，则它自己是根节点，否则递归查询它的父节点.时间复杂度为 O(\log{n}). 查询是否同集 ¶若两个节点所在树的根节点相同，则它们同集. 合并集合 ¶若 \{b,c\} 也同集，则合并其所在的集合. 将两集合根节点相连，即新建一条从 a 连向 e 的边：fa[e]=a. 路径压缩 ¶  每次查询出节点 i 所在集合的根节点 e 后，使 fa[i]=e.   再次查询 i 的根节点时，find(i) 函数就会直接返回 e，免去递归过程.   时间复杂度优化为 O(1). 该做法类似于记忆化搜索. 
    </content>
  </item>
  

  
  <item>
    <title>AC 自动机</title>
    <link>/post/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/ac-%E8%87%AA%E5%8A%A8%E6%9C%BA/</link>
    
    <summary>AC 自动机不是能自动 AC 的机器，而是一种著名的多模式串匹配算法.</summary>
    
    <content>
      简介 ¶AC 自动机不是能自动 AC 的机器，而是一种著名的多模式串匹配算法. 问题 ¶给定 n 个模式串 A_1\sim A_n 和一个长为 m 的主串 S，问有多少个模式串在 S 中出现过. 假设 n 个模式串互不相同，且字符串中仅含小写字母.可以考虑枚举 S 的所有子串并进行判断.    暴力算法（\textcolor{red}{×}） AC 自动机（\textcolor{green}{√}）     O(n^3) O(n&#43;m)    原理 ¶ Under Construction ...   模板 ¶
    </content>
  </item>
  

  
  <item>
    <title>KMP 算法</title>
    <link>/post/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/kmp-%E7%AE%97%E6%B3%95/</link>
    
    <summary>KMP 算法并不能用来看毛片，它是一种字符串匹配算法.</summary>
    
    <content>
      简介 ¶KMP 算法并不能用来看毛片，它是一种字符串匹配算法.KMP 是该算法的发明者 Kruth，Morris 和 Pratt 的名字缩写.  问题 ¶给定字符串 A（长度为 m）和 B（长度为 n），问 A 中是否包含 B ？ 考虑暴力算法：  先将 A 和 B 左端对齐. 如果匹配失败，就将 B 右移一位，直到匹配成功.  时间复杂度：O(mn).  本章统一使用红色表示不匹配，绿色表示匹配.   原理 ¶当匹配失败时，我们忽视了一些重要的信息.当第一次匹配失败时，两个绿串相等. 该绿串还有着相同的前缀1和后缀.我们管它叫做「公共前后缀」.abab 的公共前后缀为 ab. 从下面这个角度看，A 和 B 划线的两段，都是公共前后缀，它们相等. 若 B 右移后能与 A 匹配，那么 B 至少要右移 2 位，也就是使相等的两段对齐.这样就避免了一位一位地移，从而提高效率. 到此为止，KMP 的思路已经很明朗了.         1        将 A 串和 B 串左端对齐（σ 表示不定字符）.       2        从左往右比较字符，直到不匹配.此时 A 和 B 的绿串相等.       3        在绿串中找出相同的前缀和后缀（公共前后缀）.       4        右移 B 串，直到前缀和后缀竖直对齐.       5        从对齐部分的后一个字符开始，继续向右匹配，重复前面的过程.      现在还有一个问题：在程序中，如何实现字符串的右移？—— 使用指针. 指针 i,j 分别指向 A 串和 B 串，表示 A[i] 和 B[j] 前的两个绿串匹配.如果将 B 串右移 x 位，那么在程序中，只需要将 j 指针左移 x 位. pre[i] 表示 B[0\cdots i] 的公共前后缀长度，pre[ \ ] 具体怎么预处理后续会说.现在假设 pre[ \ ] 数组已经处理好了.依照刚才的思路，KMP 的主程序可以分解为以下步骤（结合下面的样例理解）：   令 i,j 分别指向 A 和 B 的开头，即 i=0,j=0.   如果 A[i]=B[j]，i 和 j 同时右移一位.   如果 A[i]≠B[j]，又分两种情况讨论：   j≠0 时，绿串的公共前后缀长度为 pre[j-1].那么就令 j=pre[j-1].   j=0 时，j 不能再往左移.此时只能将 i 右移一位.     重复 2、3 两个步骤，直到匹配完成.           1        令指针 i 和 j 分别指向 A 串和 B 串的开头.       2        A[i]=B[i]，i 和 j 同时右移一位.       3        A[i]=B[j]，i 和 j 同时右移一位.       4        A[i]=B[j]，i 和 j 同时右移一位.       5        A[i]=B[j]，i 和 j 同时右移一位.       6        A[i]≠B[j]，令 j=pre[j-1]=2.这样，A[i] 和 B[j] 前的绿串就又匹配了.  字符串的下标是从 0 开始计算的.j=2 实际上就是将 j 指向 B 串的第 3 个字符.        7        A[i]=B[j]，i 和 j 同时右移一位.       8        A[i]=B[j]，i 和 j 同时右移一位.       9        A[i]=B[j]，i 和 j 同时右移一位. 此时 j=B\;串长度  =5，指到了 B 串外面，代表匹配成功.      预处理 ¶pre[ \ ] 数组的求法和 KMP 的主程序很相似. 指针 i,j 都指向 B 串，表示当前求的是 B[0\cdots i] 的公共前后缀长度 pre[i].并且 B[0\cdots i] 的公共前后缀为 B[0\cdots j]，即 pre[i]=j&#43;1. 因为 pre[0]=0 不用求，所以直接从 pre[1] 开始求就好，初始时 i=1,j=0. 然后，我们直接采用 KMP 主程序 的策略：   如果 B[i]=B[j]，那么 pre[i]=j&#43;1，并将 i 和 j 同时右移一位.   如果 B[i]≠B[j]，又分两种情况讨论：   j≠0 时，绿串的公共前后缀长度为 pre[j-1].那么就令 j=pre[j-1].   j=0 时，绿串长度为 0，j 不能再往左移了.此时只能将 i 右移一位.     重复前两步，直到 pre[ \ ] 全部求完.   为什么可以这么做呢？因为仅当 B[i] 和 B[j] 前的若干个字符相匹配时，B[0\cdots j] 才可能是公共前后缀.而 KMP 的主程序能够维护这一特征. 也就是说，预处理 pre[ \ ] 数组，和 KMP 的主程序，其实是在干同一件事情. 模板 ¶    字符串 s 左部的任意子串为 s 的前缀，且 s 的前缀不能是 s 本身.例如 freeze 的前缀有 f，fr，fre，free，freez.&amp;#160;&amp;#x21a9;&amp;#xfe0e;    
    </content>
  </item>
  

  
  <item>
    <title>Trie 树</title>
    <link>/post/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/trie-%E6%A0%91/</link>
    
    <summary>Trie 树又叫「字典树」，能够像字典一样录入和查询多个字符串.</summary>
    
    <content>
      简介 ¶Trie 树又叫「字典树」，能够像字典一样录入和查询多个字符串. 构造 ¶一般我们会用数组保存字符串，可是这么做既浪费空间，查询速度又慢. 如果将字符串放在链表里，就会有相当一部分节点可以合并.例如 his，her，hello 的开头都是 h，那么它们可以共享同一个 h 节点.同理，her 和 hello 可以共享 he.  最后，在上方建一个空节点，指向各个字符串的开头，一棵标准的 Trie 树就建好了.至于这个空节点，纯粹是为了让程序写起来更方便.  节点 ¶Trie 树的节点存储于结构体中： 按照节点的创建顺序为其编号，令 trie[u] 表示第 u 个建立的节点.trie[u].next[&#39;s&#39;] 表示 u 号节点的子节点中，代表字符 s 的节点的编号.  在程序中，我们一般用 0 - 25 替换 a - z，数组就只要开到 next[26]. 当然，也有人习惯于用二维数组存储 Trie 树节点. 插入 ¶如何往 Trie 树中插入一个字符串？ 本着勤俭节约的精神，能共享的节点就尽量共享.例如要在刚才那棵 Trie 树中插入 thus，并且发现 t，h 可以共享，那么就只要新建 u，s 两个节点.  查询 ¶查询 Trie 树中是否有某个字符串，只需要从空节点向下搜索即可. 模板 ¶        结构体              二维数组             
    </content>
  </item>
  

  
  <item>
    <title>最近公共祖先（LCA）</title>
    <link>/post/acm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
    
    <summary>最近公共祖先（Least Common Ancestors，简称 LCA）.</summary>
    
    <content>
      简介 ¶最近公共祖先（Least Common Ancestors，简称 LCA）. 节点 p,q 的最近公共祖先 s 是这棵树中到 p,q 的距离之和最小的节点.  如何求两个节点的 LCA？         0        p,q 两个指针分别指向这两个节点，并且 p 的深度比 q 深.       1        将 p 不断往父节点方向移，直到 p,q 处于同一深度.         2        p 和 q 同时往父节点移，直到它们相遇于 s 节点.s 节点为 p 和 q 的 LCA.              var src1 = [&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;3&#34;];      var src2 = [&#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;5&#34;];      var cnt1 = 0, cnt2 = 0;        function cycle1() {          if(cnt1 == src1.length) cnt1 = 0;          document.getElementById(&#34;1&#34;).src = src1[cnt1] &#43; &#34;.svg&#34;;          cnt1 &#43;&#43;;      }        function cycle2() {          if(cnt2 == src2.length) cnt2 = 0;          document.getElementById(&#34;2&#34;).src = src2[cnt2] &#43; &#34;.svg&#34;;          cnt2 &#43;&#43;;      }        var int1 = setInterval(cycle1, 400);      var int2 = setInterval(cycle2, 400);        function book_tabs_onclick() {          clearInterval(int1);          clearInterval(int2);          cnt1 = cnt2 = 0;          cycle1();          cycle2();          int1 = setInterval(cycle1, 400);          int2 = setInterval(cycle2, 400);      }        暴力算法（\textcolor{red}{×}） LCA 算法（\textcolor{green}{√}）     预处理 \textcolor{green}{0} \textcolor{green}{O(n)}   单次查询 \textcolor{red}{O(n)} \textcolor{green}{O(\log{n})}   m 次查询 \textcolor{red}{O(mn)} \textcolor{green}{O(m\log{n})}    原理 ¶暴力算法慢在哪里？ - - p 和 q 每次只能向父节点跳一步！这是因为我们只保存了每个节点的父节点. 进一步思考，开一个二维数组 f：f[p,i] 表示 p 的第 2^i 级父节点.  一张图中最多有 2^{24} 个节点，否则光是读入这张图都会超时.因此数组只要开到 f[n,25]. 第一步 ¶如果已经预处理出了 f 数组，如何让 p 向上跳到和 q 同样深的位置？ 采用「试跳法」.枚举 i=24→0：   若 f[p,i] 的深度小于 q 的深度，会跳过头，所以选择不跳；   否则就令 p = f[p,i].   为什么要从 24 开始枚举 i 呢？因为 p 不可能有超过 2^{24} 级的父节点. 时间复杂度为 O(24). 第二步 ¶令 p 和 q 同时往父节点跳，直到它们相遇. 仍然使用「试跳法」，枚举 i=24→0：   若 f[p,i] = f[q,i]，此时 p,q 同时向上跳 2^i 步会相遇，但是我们选择不跳.   若 f[p,i] ≠ f[q,i]，令 p = f[p,i], q = f[q,i]，此时 p,q 离相遇又近了一步.   枚举结束时，p 和 q 处于相遇和不相遇的临界状态，如下图.p 或 q 的父节点就是 LCA.  合并两个步骤，得到求 LCA 的代码： 预处理 ¶出于 LCA() 函数的需要，我们还需要预处理：   每个节点的深度 d[u]；   f 数组.   首先 d[u]=d[u 的父节点]&#43;1，我们可以用一次深搜搞定 d 数组. u 的 2^{i&#43;1} 级父节点，同时也是「u 的 2^i 级父节点」的 2^i 级父节点.  计算顺序：f[u,1→24]. 如果你还不理解为什么要算到 f[u,24]，请再仔细看一遍 原理. 采用 树形 DP 方法进行预处理.时间复杂度为 O(24n). 模板 ¶
    </content>
  </item>
  

  
  <item>
    <title>RMQ 算法</title>
    <link>/post/acm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/rmq-%E7%AE%97%E6%B3%95/</link>
    
    <summary>RMQ 是 Range Maximum/Minimum Query 的缩写，意为区间的最大（或最小）值.</summary>
    
    <content>
      简介 ¶RMQ 是 Range Maximum/Minimum Query 的缩写，意为区间的最大（或最小）值. 问题 ¶已知数组 A 中一共有 n 个元素，给出 m 次询问：  给出 l,r，求 A[l\cdots r] 中的最大值.      暴力算法（\color{red}{×}） RMQ 算法（\color{green}{\sqrt{}}）     预处理 \color{green}{O(0)} \color{green}{O(n\log{n})}   单次查询 \color{green}{O(n)} \color{green}{O(1)}   m 次询问 \color{red}{O(mn)} \color{green}{O(m)}    预处理 ¶f[i,j] 表示从 A[i] 开始往后数 2^j 个数的最大值，也就是 \max\{A[i]\sim A[i&#43;2^j-1]\}.将 2^j 个数从中间平均分成两部分，每一部分的元素为 2^{j-1} 个. 整个区间的最大值一定为左右两部分的最大值：  由于 f[*,j] 是由 f[*,j-1] 推出的，故第一层循环枚举 j=0→\log{n}.    初始条件 计算顺序 时间复杂度     f[i,0]=A[i] f[1→n,0→\log{n}] O(n\log{n})    原理 ¶现在我们要查询 A[l]\sim A[r] 的最大值.A[l]\sim A[r] 一共有 r-l&#43;1 个元素，我们设 s=\log(r-l&#43;1)，然后在整个区间内划出两个长度为 2^s 的子区间：  根据前面的定义，左子区间的最大值为 f[l,s]，右子区间的最大值为 f[r-2^s&#43;1,s]. 虽然两个子区间有重叠部分，但它们包含了整个 [l,r] 区间.因此  由于 C&#43;&#43; 提供的 log2() 函数太慢，于是预处理 Log[ \ ] 数组替代 log2() 函数. 模板 ¶
    </content>
  </item>
  

  
  <item>
    <title>哈希表</title>
    <link>/post/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</link>
    
    <summary>哈希表 由 哈希函数 和 链表 组成，相当于「超级数组」.</summary>
    
    <content>
      简介 ¶哈希表 由 哈希函数 和 链表 组成，相当于「超级数组」.   数组的下标1可以是整数，浮点数，字符串等.   不用定义数组的长度.   问题 ¶医院的排队系统需要记录每个病人对应的问诊顺序.此处假设每个病人的名称都是数字.    名称 32 26 75 4     问诊顺序 1 2 3 4    p[i] 表示「名称为 i 的病人的问诊顺序」.查询问诊顺序的时间复杂度为 O(1). 然而总有某些病人不按套路取名.    名称 114514 2333 2147483647 404     问诊顺序 1 2 3 4    要存储 p[2147483647]=3，得先开一个长度为 2147483647 的数组.这明显不现实. 构造 ¶开一个如此丑陋的数组，会浪费超过 99\% 的空间.毕竟只用到了其中的四个元素.有没有办法使数组只占很少空间？ 设计哈希函数 getHash()，用 p[getHash(i)] 表示病人 i 的问诊顺序.对于本例，有：  这样数组就只要开到 p[5].但这么做会导致其它问题：病人 114514 和病人 404 的问诊顺序会同时存入 p[4]，因为 getHash(114514)=getHash(404)=4.于是我们可以将 getHash() 相同的病人放在同一个链表里.  查询病人 i 的问诊顺序时，只需在 getHash(i) 开头的链表中找到该病人. 哈希函数 ¶getHash() 有多种构造方式：   取模法  其中 p 为质数（如 999997）.   乘积取整法  其中 p 为质数，A 为区间 (0,1) 中的无理数（如 \su\frac{\sqrt{5}-1}{2}）.   数位分析法  其中 s 为字符串，b,p 为质数.详见 哈希函数.   模板 ¶    中括号里的数称之为「下标」，例如 a[14] 的下标为 14.&amp;#160;&amp;#x21a9;&amp;#xfe0e;    
    </content>
  </item>
  

  
  <item>
    <title>哈希函数</title>
    <link>/post/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</link>
    
    <summary>哈希函数 $getHash()$ 能够将字符串转化成整数，并保证字符串不同，对应的整数也不同.</summary>
    
    <content>
      简介 ¶哈希函数 getHash() 能够将字符串转化成整数，并保证字符串不同，对应的整数也不同.该整数称为哈希值.这样，判断两个字符串是否相等，就只要判断它们的哈希值是否相等. 原理 ¶假设所有字符串中只包含小写字符 a\sim z.以字符串 fantasy 为例：  将 a\sim z 替换为数字 1\sim 26，得到一个数列.    将该数列看作一个 27 进制数（逢 27 进一）.   按此方法设计的哈希函数，可保证不同字符串的哈希值必不同.但字符串长度过长时，哈希值会超出 long long 的范围. 滚动哈希 ¶为解决一般哈希函数适用范围有限的问题，采用滚动哈希. 选取两个合适的质数 b 和 p，将字符串看作 b 进制数（b &amp;gt; 字符种数）. getHash(fantasy)=(6\cdot b^6&#43;1\cdot b^5&#43;14\cdot b^4&#43;\cdots&#43;25\cdot b^0)\%p  按此方法设计的哈希函数，不同字符串的哈希值相同的概率较小，且哈希值不会超出 long long 的范围.时间复杂度为 O(n). 哈希冲突 ¶使用 滚动哈希 时，有概率会使不同字符串的哈希值相同.该现象称为哈希冲突. 一种降低哈希冲突概率的可靠方法是双哈希：使用两组不同的质数 b_1,p_1 和 b_2,p_2，分别计算哈希值.只有两个哈希值分别相同，才能判定字符串的匹配. 
    </content>
  </item>
  

  
  <item>
    <title>线段树</title>
    <link>/post/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
    
    <summary>数组 $A$ 中共 $n$ 个元素，对其反复进行以下操作共 $m$ 次：</summary>
    
    <content>
      问题 ¶数组 A 中共 n 个元素，对其反复进行以下操作共 m 次：   单点修改：将 A[id] 修改为 v.   区间查询：查询 A[l\cdots r] 的最小值.   区间修改：将 A[l\cdots r] 每个数加上 v.       暴力算法（\textcolor{red}{×}） 线段树（\textcolor{green}{√}）     单点修改 \textcolor{green}{O(1)} \textcolor{green}{O(\log{n})}   区间查询 \textcolor{red}{O(n)} \textcolor{green}{O(\log{n})}   区间修改 \textcolor{red}{O(n)} \textcolor{green}{O(\log{n})}   m 次操作 \textcolor{red}{O(mn)} \textcolor{green}{O(m\log{n})}    构造 ¶查询数组 A={6,2,3,7,1,5,4,2} 中的最小值时，通常使用「两两比较法」：每次比较相邻两项，只保留更小的一项.比较的过程可以画成一棵二叉树，树根是答案.  这么做又有什么好处呢？假如数列中的 1 被改为 7，你可以通过修改极少的数值，重新得出正确答案.  线段树就是这样的一颗二叉树，它的每个节点都代表一段区间中的最小值. 线段树具有以下性质：   根节点的值为 t[1]，代表整个数组的最小值.   t[u] 的左子节点为 t[2u]，右子节点为 t[2u&#43;1].   t[u]=\min(t[2u],t[2u&#43;1]).    因此，每个节点需要保存以下信息：   节点的值：val.   节点代表的区间：[l,r].   从根节点开始，自顶向下递归构建线段树.时间复杂度为 O(n\log{n}). 单点修改 ¶假设你要将 A[5] 修改为 3，则 A[5] 的所有祖先都有可能变动.  set(u,id,v)：在以节点 u 为根的子树中，找到 A[id]，并将其更新为 v.   令 \su m=\frac{l(u)&#43;r(u)}{2}；   若 id≤m，则 A[id] 在左子树中，搜索左子树；   若 id&amp;gt;m，则 A[id] 在右子树中，搜索右子树；   更新当前节点值：t[u]=\min(t[2u],t[2u&#43;1]).   时间复杂度为 O(\log{n}). 根节点是搜索的入口.执行 set(1, id, v) 以进行单点修改. 区间查询 ¶线段树中，每个节点代表一个区间.那么反过来想，每个区间都可以用若干节点表示.例如 A[1\cdots 6] 可以用 t[2] 和 t[6] 表示，那么 A[1\cdots 6] 的最小值 =\min(t[2],t[6])=2.  从根节点开始，自顶向下搜索出范围在 [l,r] 之内的节点，这些节点的最小值即为答案. get(u,l,r)：从节点 u 开始，向下搜索 A[l\cdots r] 的最小值.   若 u 的范围在 [l,r] 之内，直接返回 t[u]；   若 u 的范围与 [l,r] 不重叠，返回 ∞1；   否则递归搜索 u 的两个子节点.   时间复杂度为 O(\log{n}).执行 get(1,l,r) 以进行区间查询. 区间修改 &#43; 延迟标记 ¶如果一次性将 A[3\cdots 8] 每个数加上 v，需要更新大量节点，时间复杂度接近 O(n\log{n}).这不是我们希望看到的.  事实上，大部分节点用不着马上更新——直到它们再次被访问.于是我们可以先给部分节点打标记. 在本例中，t[3] 和 t[5] 被打上了标记，这代表它们的所有子节点都还没加上 v.  当访问 A[5\cdots 6] 时，再更新 t[3] 的左子树 .t[3] 的标记被下传到了它的右节点 t[7].  代码与 区间查询 类似.时间复杂度为 O(\log{n}). 同时，单点修改 和 区间查询 需要添加下传标记的操作. 模板 ¶区间和线段树 ¶线段树还可以查询区间和. 令每个节点代表一段区间的元素和.递推方程应为 t[u]=t[2u]&#43;t[2u&#43;1].  若 t[u] 表示区间 [l,r]，而 A[l\cdots r] 每个数都要加上 v，则 t[u] 需要加上 (r-l&#43;1)×v.因此标记下传函数也需要调整. 权值线段树 ¶令每个节点代表一段区间内的元素个数.下图是基于数组 A=\{2,3,6\} 构建的权值线段树.t[2] 代表的区间为 [1,4]，t[2]=2 说明数组 A 中有 2 个元素在 [1,4] 区间中，它们分别是 2 和 3.  权值线段树可以用来做什么呢？— — 它可以求任一区间内第 k 小的数.   未完待续 \cdots \ \cdots       \min(∞,a)=a，因此返回 ∞ 相当于不参与最小值的比较.&amp;#160;&amp;#x21a9;&amp;#xfe0e;    
    </content>
  </item>
  

  
  <item>
    <title>树状数组</title>
    <link>/post/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link>
    
    <summary>数组 $A$ 中共 $n$ 个元素，对其反复进行以下操作共 $m$ 次：</summary>
    
    <content>
      问题 ¶数组 A 中共 n 个元素，对其反复进行以下操作共 m 次：   单点修改：将 A[ x] 加上 k.   区间查询：查询 A[l\cdots r] 的和.       暴力算法（\textcolor{red}{×}） 树状数组（\textcolor{green}{√}）     单点修改 \textcolor{green}{O(1)} \textcolor{green}{O(\log{n})}   区间查询 \textcolor{red}{O(n)} \textcolor{green}{O(\log{n})}   m 次操作 \textcolor{red}{O(mn)} \textcolor{green}{O(m\log{n})}    构造 ¶在原数组的上方构建树型结构，每个节点表示一段区间和：  C_1=A_1； C_2=A_1&#43;A_2； C_3=A_3； C_4=A_1&#43;A_2&#43;A_3&#43;A_4； \cdots \ \cdots 父节点 ¶如何求 C_i 的父节点？ 将 C 数组的下标转换成二进制数，观察该图.    C[0001] 的父节点为 C[0010].   C[0100] 的父节点为 C[1000].   C[0101] 的父节点为 C[0110]. \cdots \ \cdots   不难总结出规律：  C_i 的父节点为 C[i&#43; lowbit(i) ].  左邻节点 ¶C_i 的「左邻节点」与 C_i 的左端相邻.例如 C_5 的左邻节点为 C_4.  观察同一张图：    C[0011] 的左邻节点为 C[0010].   C[0101] 的左邻节点为 C[0100].   C[0110] 的左邻节点为 C[0100].   总结规律：  C_i 的左邻节点为 C[i-lowbit(i)].  单点修改 ¶将 A[x] 增加 k，A[x] 的所有祖先都会跟着变动.以 A_3 为例：  C_3=\textcolor{red}{A_3}； C_4=A_1&#43;A_2&#43;\textcolor{red}{A_3}&#43;A_4； C_8=A_1&#43;A_2&#43;\textcolor{red}{A_3}&#43;A_4&#43;A_5&#43;A_6&#43;A_7&#43;A_8. 因此，修改 A[3] 的同时，C_3,C_4,C_8 也需要加上 k. 对于给定的 x，从 C_x 开始逐层访问 父节点，并给其值加上 k.时间复杂度为 O(\log{n}). 区间查询 ¶采用 前缀和 思想.sum[x] 表示 A[1]&#43;A[2]&#43;\cdots&#43;A[x]，则： A[l\cdots r] 的和 =sum[r]-sum[l-1]  自此，问题转换为求 sum[x].以 sum[7] 为例：  C_4=A_1&#43;A_2&#43;A_3&#43;A_4； C_6=A_5&#43;A_6； C_7=A_7； 因而 sum[7]=C_4&#43;C_6&#43;C_7. 查询 sum[x] 时，从 C_x 开始依次遍历 左邻节点.时间复杂度为 O(\log{n}). 模板 ¶拓展 ¶区间修改 ¶如果你已经学过 差分，区间修改就容易的多.   在数组 A 的「差分数组」上建立树状数组.   将 A[l\cdots r] 所有元素都加上 v 时，f[l] 增加了 v，f[r&#43;1] 减少了 v.   
    </content>
  </item>
  

  
  <item>
    <title>数位 DP</title>
    <link>/post/acm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8D-dp/</link>
    
    <summary>如何统计区间 $[l,r]$ 中有多少整数符合某条件？</summary>
    
    <content>
      简介 ¶如何统计区间 [l,r] 中有多少整数符合某条件？  暴力算法，枚举 [l,r] 中的每一个整数，逐个判断是否满足条件，此方法遇大数据必 gg. 优雅地使用数位 DP.  问题 ¶统计区间 [l,r]（0≤l&amp;lt;r≤100）中有多少整数符合「相邻两个数字之差 ≥2」. 预处理 ¶采用「试填法」：从个位填到最高位，如果第 d 位填了 i，那么第 d&#43;1 位只能填 [0,i-2] 或 [i&#43;2,9] 中的整数. f[i,d] 表示「所有最高位为 i 的 d 位数中，符合条件的个数」. 通过给定条件可推出：     初始条件 f[i,1]=1 计算顺序 f[0→9,2→n]     时间复杂度 O(10^2\log{n})      数位统计 ¶考虑 前缀和 思想： dp(n) 表示 [0,n] 中有多少个数满足条件. [l,r] 中符合条件的个数 =dp(r)-dp(l-1). dp(n) 的实现步骤： step 1 ¶提取 n 每一位上的数字，存入数组 at[ \ ]： step 2 ¶所有 1\cdots cap-1 位数都被包含于 [0,n] 区间中. 统计它们中符合条件的个数： step 3 ¶统计所有 cap 位数中符合条件的个数. 使用「试填法」，枚举 d=cap→1，从最高位填到最低位，并使填的数 &amp;lt;n：   若 d=cap，该位不能填 0，只能填 1\cdots at[d]-1. 统计符合条件的情况；   若 d≠cap，该位只能填 0\cdots at[d]-1. 统计符合条件的情况；   若此时 |at[d&#43;1]-at[d]|&amp;lt;2，下一位无论怎么填都不符合条件，跳出循环；   若上一步未跳出循环且 d=1，说明 n 本身也符合条件. 但「试填法」最多只填到 n-1，故还要多算一个.     模板 ¶
    </content>
  </item>
  

  
  <item>
    <title>树形 DP</title>
    <link>/post/acm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2-dp/</link>
    
    <summary>树形 DP 以树形结构为研究对象.</summary>
    
    <content>
      简介 ¶树形 DP 以树形结构为研究对象. 通常设 f[u] 为树中 u 号节点的值，利用树形关系推出其它节点的值. DP 过程多为 记忆化搜索. 例 1 ¶给定一棵 n 个点，m 条边的树，顶点编号为 1\sim n，且以 1 号节点为根. 以 i 号节点为根的子树有几个节点？ f[i]：以 i 号节点为根的子树的节点数. Son[i]：i 号节点的子节点集合. 计算顺序为 f[子节点]→f[父节点]. 使用记忆化搜索. 例 2 ¶公司有 n 个人，编号为 1\cdots n，其中 1 号员工是 boss. 现要举⾏⼀场晚会，如果邀请了某个⼈，那么他的上司不会来（他上司的上司，上司的上司的上司 \cdots 都可以来）. 每个⼈都有⼀个欢乐值，给出公司所有人的上下级关系，求⼀个邀请⽅案，使欢乐值的和最⼤. f[i,j]：从员工 i 和所有下属中邀请部分人参会的最大欢乐值. 当 j=0 时 i 号员工不参会，j=1 时参会. Son[i]：员工 i 的下属集合.  若 i 号员工参会，他的直接下属都不来：   若 i 号员工参会，他的直接下属爱来不来，于是取最大值：  时间复杂度为 O(n)，最终答案为 \max\{f[1,0],f[1,1]\}. 树形 DP &#43; 背包 DP ¶处理某些问题时，需要结合树形 DP 和背包 DP 的思想. 现有 n 门课程，第 i 门课程的学分为 s_i，每门课程有 0 或 1 门先修课.有先修课的课程需要先学完先修课，才能学习该课程.求学习 m 门课程能获得的最多学分. 将每门课程看作树中的节点，a→b 代表 a 比 b 先修： 为了方便解决问题，新增 0 号节点，使其指向所有无先修课的课程： f[u,j] 表示以 u 为根节点，选 j 个节点，获得的最大学分. dfs(u) 的功能是算出以 u 为根节点时，分别选 0\sim m 个节点时能获得的最大学分. 执行 dfs(u) 时，枚举 u 的子节点 v，在内层循环枚举选取的节点数 j=m→1：   将 j 个节点分成两组，一组 k 个，另一组 j-k 个；   将第一组 k 个节点放在以 v 为根节点的子树中，最大学分为 f[v][k]；   将第二组 j-k 个节点放在以 u 为根节点的子树中，但不放在以 v 为根节点的子树中，最大学分为 f[u][j-k].       初始条件 f[i,1]=s[i] 边界条件 f[0,m]     时间复杂度 O(n^3)      在主程序中执行 dfs(0) 后输出 f[0,m] 即可. 
    </content>
  </item>
  

  
  <item>
    <title>拓扑排序</title>
    <link>/post/acm/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
    
    <summary>给出 $n$ 个元素的 $m$ 组关系：$a &amp;gt; b,a &amp;gt; c,b &amp;gt; c,b &amp;gt; d,\cdots$，试将这 $n$ 个元素按大小排序.</summary>
    
    <content>
      简介 ¶给出 n 个元素的 m 组关系：a &amp;gt; b,a &amp;gt; c,b &amp;gt; c,b &amp;gt; d,\cdots，试将这 n 个元素按大小排序. 将上述关系转化为有向图，a → b 代表 a &amp;gt; b.这类反映节点大小关系的图称作 AOV 网.  拓扑排序求的是符合条件的优先顺序，即拓扑序列. 原理 ¶根据定义，没被箭头指着的节点（即入度为 0 的节点）是当前最大的节点.         1        节点 a 的入度为 0.在拓扑序列中追加 a，并删除 a 和它的所有邻边：  拓扑序列：a      2        节点 e 的入度为 0.在拓扑序列中追加 e，并删除 e 和它的所有邻边：  拓扑序列：a,e      3        节点 b 的入度为 0.在拓扑序列中追加 b，并删除 b 和它的所有邻边：  拓扑序列：a,e,b      4        节点 c 的入度为 0.在拓扑序列中追加 c，并删除 c 和它的所有邻边：  拓扑序列：a,e,b,c      5        节点 d 的入度为 0.在拓扑序列中追加 d，并删除 d 和它的所有邻边：  拓扑序列：a,e,b,c,d      6        节点 f 的入度为 0.在拓扑序列中追加 f，并删除 f 和它的所有邻边：  拓扑序列：a,e,b,c,d,f     故样例的一种拓扑序列为 a,e,b,c,d,f.  同一张 AOV 网可能有多个拓扑序列.   deg[u]：节点 u 的入度，需要预处理.   定义一个队列，用于存放节点；   将所有入度为 0 的节点入队；   取出队头的节点，并删除它的所有出边.若出现入度为零的节点，将其入队.   拓扑排序结束时，若拓扑序列未包含全部节点，则剩下的节点形成了闭环.此时不存在拓扑序列. 时间复杂度为 O(n&#43;m). 
    </content>
  </item>
  

  
  <item>
    <title>最小生成树</title>
    <link>/post/acm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
    
    <summary>无向图 $G$ 的生成树满足以下性质：</summary>
    
    <content>
      简介 ¶无向图 G 的生成树满足以下性质：  包含 G 中的所有节点. 任意两个节点都 连通. 具有 树 的所有性质.  图 b 和图 c 皆为图 a 的生成树.  最小生成树，即边权和最小的生成树.对于 n 个节点的无向图，最小生成树一定有 n-1 条边. Kruskal 算法 ¶Kruskal 是一种贪心算法.  将 m 条边按照边权升序排序； 从小到大枚举边：   若此边的两个顶点未连通，则在树中加入此边，并连通两个顶点. 若此边的两个顶点已连通，直接跳到下一条边.  重复直到树中共加入 n-1 条边. 使用 并查集 判断和维护两个顶点是否连通. 时间复杂度为 O(m\log{m})，适用于稀疏图. Prim 算法 ¶dis[u] 表示节点 u 到树的最短距离.  建立一棵只有 1 号节点的树，dis[1]=0； 选择离树最近（dis 最小）的节点加入树，对该点的所有临边进行 松弛操作.重复执行直到加入 n-1 条边.  时间复杂度为 O(n^2)，适用于稠密图. 
    </content>
  </item>
  

  
  <item>
    <title>图</title>
    <link>/post/acm/%E5%9B%BE%E8%AE%BA/%E5%9B%BE/</link>
    
    <summary>图（Graph） 由若干 顶点 和 边 组成，用大写字母 $G$ 表示，$V$ 为顶点集合，$E$ 为边集合，记作 $G=(V,E)$.</summary>
    
    <content>
      定义 ¶图（Graph） 由若干 顶点 和 边 组成，用大写字母 G 表示，V 为顶点集合，E 为边集合，记作 G=(V,E).  图是描述实际问题的工具.如进行城市道规划时，可将每个城市视作顶点，连接城市的道路视作边. 边的方向 ¶ 图的每条边都有起点和终点，则图为 有向图； 相反，边没有方向（可以理解为双向）的图为 无向图（双向图）.   边权和点权 ¶为解决实际问题，引入 边权 和 点权 的概念：  边权 及边的长度.解决最短路径问题时，将城市视作顶点，城市之间的道路长度视作边权； 点权 即点的大小.解决最小收费问题时，将收费站视作顶点，收费站之间的道路视作边，通过收费站支付的费用视作点权.  度数 ¶若图中有 d 条边与节点 i 相连，则节点 i 的 度数 为 d（即节点的 连边 个数）.如下图，节点 1 的度为 6：   若有向图中有 d 条边的 终点 是节点 i，则节点 i 的 入度 为 d（即节点的 入边 个数）； 若有向图中有 d 条边的 起点 是节点 i，则节点 i 的 出度 为 d（即节点的 出边 个数）；  子图 ¶图 G 的子图 H 满足以下条件：  G 中包含 H 的所有节点和边； G 和 H 同时为无向图或有向图.  即 G=(V,E),H=(V&#39;,E&#39;),V&#39;\in V,E&#39;\in E.如下图，H 是 G 的子图：  路径和连通 ¶从节点 i 走到节点 j，经过的边的序列为 i 到 j 的 路径.路径的长度为经过边的边权和. 如下图，节点 1 到 6 的一条路径为 1-4-5-6.  若两个节点之间存在路径，则称它们 连通. 回路（环） ¶若图中存在起点和终点相同的路径，则此路径称作 回路（环）. 完全图和连通图 ¶  若无向图 G 的任意两个节点之间都有连边，则 G 称为 完全图. n 个节点的完全图有 \su\frac{1}{2}n(n-1) 条边；   若无向图 G 的任意两个节点都连通，则 G 称为 连通图. n 个节点的连通图至少有 n-1 条边.   强连通分量 ¶ 若有向图 G 的任意两个节点都连通，则 G 称为 强连通图； 若有向图 G 的子图 H 是强连通图，则 H 称为 G 的 强连通分量.  图的存储 ¶直接存边 ¶把每条边的起点、终点、长度存入数组中.         结构体              打散             邻接矩阵 ¶用二维数组 g（邻接矩阵）存储边长，g[i,j] 表示边 i→j 的权值.缺点是不能存储重边、浪费空间. 邻接表 ¶把节点 i 的所有相邻节点插入以 head[i] 开头的链表中.  
    </content>
  </item>
  

  
  <item>
    <title>树</title>
    <link>/post/acm/%E5%9B%BE%E8%AE%BA/%E6%A0%91/</link>
    
    <summary>树有多种等价的定义方式：</summary>
    
    <content>
      定义 ¶树有多种等价的定义方式：  连通且无环的无向图. 有 n 个节点和 n-1 条边的无向图. 任意两个顶点间只有一条路径的无向图.  图论中的树看起来更像现实中倒悬的树：  树的节点存在「父子关系」：  有连边的两个节点中，上节点为下节点的父节点.节点 2 是节点 5 的父节点； 有连边的两个节点中，下节点为上节点的子节点，节点 5 是节点 2 的子节点； 没有父节点的节点为根节点，节点 1； 没有子节点的节点为叶节点，节点 5,6,3,8,9.  有根树和无根树 ¶有根树必须明确根节点，而无根树的任意节点都可以是根节点.下面的左图和右图是同一棵无根树：  子树 ¶将节点 i 和其父节点断开，分裂出的以 i 为根的新树，称作节点 i 的子树.如下图，红色部分为节点 3 的子树.  层和深度 ¶定义根节点在第 1 层，子节点层数 = 父节点层数 &#43; \ 1：  树的深度 = 总层数.上图中树的深度为 4.树中各个节点的深度为节点所在的层数. 二叉树 ¶任意节点的子节点数量 ≤2 的树是二叉树：  满二叉树 ¶深度为 k 的二叉树最多有 2^k-1 个节点.节点最多的那棵树是满二叉树：  满二叉树除最后一层外，其它层任意节点都有 2 个子节点. 完全二叉树 ¶将满二叉树最后一层右边连续的若干节点删除，得到完全二叉树：  满二叉树是一类特殊的二叉树. 森林 ¶多棵树组成的图为森林：  二叉树的遍历 ¶对于二叉树，可以使用 DFS 算法 遍历所有节点.二叉树定义了 3 种遍历方式，遍历顺序各不同.          前序遍历          访问根节点 u；   递归遍历 u 的左子树；   递归遍历 u 的右子树.   上图的前序遍历顺序为 1→2→4→5→3.       中序遍历          递归遍历 u 的左子树；   访问根节点 u；   递归遍历 u 的右子树.   上图的中序遍历顺序为 4→2→5→1→3.       后序遍历          递归遍历 u 的左子树；   递归遍历 u 的右子树；   访问根节点 u.   上图的后序遍历顺序为 4→5→2→3→1.      二叉树的恢复 ¶给定一棵二叉树的前序和中序遍历序列，求后序遍历序列.          前序遍历：DBACEGF. 中序遍历：ABCDEFG.             后序遍历：ACBFGED.       阅读程序，得到各个遍历方式的规律：            前序遍历： 第一个元素是根节点.                  中序遍历： 根节点左边的都在左子树，右边的都在右子树.                  后序遍历： 最后一个元素是根节点.           根据前序遍历可以确定 D 是根节点.于是在中序遍历序列中找到 D.  处于 D 左边的 ABC 在 D 的左子树上；D 右边的 EFG 在右子树上.自此，我们可以大致确定这棵二叉树的形状：  比较整棵树的前序、中序遍历序列，还可以得出左右子树的前序、中序遍历序列： 前序遍历：\textcolor{red}{D}\textcolor{green}{BAC}\textcolor{blue}{EGF}. 中序遍历：\textcolor{green}{ABC}\textcolor{red}{D}\textcolor{blue}{EFG}.            左子树：   前序遍历：BAC.   中序遍历：ABC.                   右子树：   前序遍历：EGF.   中序遍历：EFG.            对左右子树进行相同的操作，不难得出整棵树的结构.  最后再后序遍历依次，输出序列. 
    </content>
  </item>
  

  
  <item>
    <title>链表</title>
    <link>/post/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</link>
    
    <summary> 链表只能按顺序依次访问元素，而数组支持随机访问.</summary>
    
    <content>
      简介 ¶ 链表只能按顺序依次访问元素，而数组支持随机访问. 链表支持在任意位置插入或删除元素，而数组不支持.  链表节点 ¶用一个结构体表示链表的节点，其中可以存储任意数据.每个节点有 prev 和 next 两个指针，指向前后相邻的节点.  初始化 ¶初始化链表时，额外建立两个节点 head 和 tail 代表链表头尾，把实际节点存储在 head 与 tail 之间，简化链表边界的判断. 插入/删除节点 ¶如何在 1 和 2 之间插入 3 ？           Step 1              Step 2         删除节点运用到类似的方法. 查找节点 ¶清空链表 ¶用数组模拟链表 ¶使用指针动态分配空间，效率较低且不稳定.一般使用数组模拟链表. 
    </content>
  </item>
  

  
  <item>
    <title>栈</title>
    <link>/post/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</link>
    
    <summary>栈是一种「先进后出」的数据结构.</summary>
    
    <content>
      简介 ¶栈是一种「先进后出」的数据结构.类似于在桶中堆积物品，取物品时只能从顶端开始取，最先进桶的被压在最底下，最后被取出来.基本操作见 STL Stack.  表达式计算 ¶算术表达式分为三类（op 为运算符，A,B 为数字或表达式）：  中缀表达式：全国人民都在用的表达式，如「5×(3&#43;2)」； 前缀表达式：形如「op \ \textcolor{red}{A} \ \textcolor{blue}{B}」，如「× \ \textcolor{red}{5} \ \textcolor{blue}{&#43;} \ \textcolor{blue}{3} \ \textcolor{blue}{2}」； 后缀表达式：形如「\textcolor{red}{A} \ \textcolor{blue}{B} \ op」，如「\textcolor{red}{3} \ \textcolor{red}{2} \ \textcolor{red}{&#43;} \ \textcolor{blue}{5} \ ×」.  计算前/后缀表达式时，先递归求出 A,B 的值，二者再做 op 运算.计算方案是唯一确定的，且不需要使用括号.计算后缀表达式的算法最容易设计. 后缀表达式 ¶ 定义一个栈，用于存放数； 逐一扫描后缀表达式中的元素：  若扫到一个数 n，则把 n 入栈； 若扫到运算符 op ，则弹出栈顶的两个元素，二者做 op 计算.将计算结果入栈.    最终的栈顶元素就是计算结果.时间复杂度为 O(n). 中缀表达式 ¶先将中缀表达式转换成 后缀表达式 再计算.  定义一个栈，用于存放运算符； 逐一扫描中缀表达式中的元素：  若扫到一个数 n，直接输出 n； 若扫到「左括号」，把左括号入栈； 若扫到「右括号」，重复取栈顶并输出，直到栈顶为左括号，再出栈左括号； 若扫到其它运算符 op，重复取栈顶并输出，直到栈顶的优先级大于 op，再把 op 入栈.    运算符优先级越大，越晚出栈，因此可以将「左括号」的优先级视作最低，「右括号」的优先级视作最高. 时间复杂度为 O(n).    运算符 ( &#43;/- ×/÷ \wedge )     优先级 最低（0） 低（1） 中（2） 高（3） 最高（4）    单调栈 ¶单调栈中的元素从栈底到栈顶满足单调性. 插入元素 ¶将元素 x 入栈，同时维护栈的单调性.以单调递增栈为例：  从栈顶依次弹掉比 x 大的元素，保证 x≥ 栈顶； 将 x 入栈.  应用 ¶单调递增栈可以实现快速查询「左边第一个更小的元素」.例如 A=\{1,2,5,4,3,6\}，A_5=3 的左边第一个比它小的元素是 A_2=2. 顺序扫描 A，将 A_i 插入单调栈前，栈中比 A_i 大的元素都被弹掉了，栈顶元素即为左边第一个比 A_i 小的元素.  求左边第一个更小的元素：顺序扫描 &#43; 单调递增栈. 求左边第一个更大的元素：顺序扫描 &#43; 单调递减栈. 求右边第一个更小的元素：倒序扫描 &#43; 单调递增栈. 求右边第一个更大的元素：倒序扫描 &#43; 单调递减栈.  
    </content>
  </item>
  

  
  <item>
    <title>队列</title>
    <link>/post/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</link>
    
    <summary>队列是一种「先进先出」的数据结构.</summary>
    
    <content>
      简介 ¶队列是一种「先进先出」的数据结构.元素从队列的前端进入（入队），从末端离开（出队），类似于排队.基本操作见 STL Queue.  双向队列 ¶队列元素只能从一端进，另一端出，有时无法满足问题的需要.双向队列应运而生，它支持从两端插入或删除元素. 双向队列的基本操作见 STL Deque. 单调队列 ¶单调队列的元素从队头到队尾满足单调性，适用于查询某一动态区间的最大（或最小）元素. 插入元素 ¶将 A[i] 入队，维护队列单调性，同时保证队列元素在 A[p\cdots i] 范围内.以单调递增队列为例：   重复弹出队头，直到队头 ≥p；   重复弹出队尾，直到 A[队尾]&amp;lt;A[i]（若单调递减，则重复直到 A[队尾]&amp;gt;A[i]）.   将 i 入队.   涉及双端操作，须使用双向队列.此时 A[p\cdots i] 范围内最小元素为 A[队头]. 滑动窗口 ¶一个滑动窗口（长度为 k）从数组 A （长度为 n）的左端移动到右端，每次只向右移一位.求每次滑动时窗口区中的最大值. 示例（k=3,n=8，红色数值在窗口区内）：    A_1 A_2 A_3 A_4 A_5 A_6 A_7 A_8 最大值     1 3 -1 -3 5 3 6 7 3   1 3 -1 -3 5 3 6 7 3   1 3 -1 -3 5 3 6 7 5   1 3 -1 -3 5 3 6 7 5   1 3 -1 -3 5 3 6 7 6   1 3 -1 -3 5 3 6 7 7    朴素算法 ¶枚举 i=k\rightarrow n，枚举出区间 [i-k&#43;1,i] 中的最大整数.时间复杂度为 O(nk). 单调队列优化 ¶使用单调递减队列优化「查找区间 [i-k&#43;1,i] 中的最大整数」的效率.时间复杂度为 O(n). 
    </content>
  </item>
  

  
  <item>
    <title>状压 DP</title>
    <link>/post/acm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8B-dp/</link>
    
    <summary>在程序中，我们如何保存一面棋盘？</summary>
    
    <content>
      简介 ¶在程序中，我们如何保存一面棋盘？   用 bool 数组 A[ \ ][ \ ].A[i][j]=1 表示第 i 行第 j 列有一枚棋子. 现在我摆出了棋盘的第 1 行和第 4 行，并规定任意两个棋子不能相邻，则中间两行一共有多少种可行的摆法？   设 f[\square\!\square\!\square\!\square][i] 表示从第 1 行摆到第 i 行，且第 i 行摆放 \square\!\square\!\square\!\square\! 的可行方案总数. 由于第一行只能为 \blacksquare\!\square\!\blacksquare\!\square，因此 f[\blacksquare\!\square\!\blacksquare\!\square][1]=1（\square 表示这一格没有棋子，\blacksquare 表示有棋子）.现在的目标是求 f[\square\!\blacksquare\!\square\!\blacksquare][4]. 因为黑棋和白棋不相邻，而第 4 行已经给出，所以第 3 行有 4 种摆法（全空着也算一种摆法）：                                                         于是可以列出递推方程：   但这么做未免也太滑稽了，而且 C&#43;&#43; 并不支持特殊符号.那怎么办呢？ 还记得我们如何 在程序中保存棋盘 吗？对，用 bool 数组.例如 \square\!\blacksquare\!\square\!\blacksquare 可以用 bool 数组表示为 \{0, 1, 0, 1\}，然后再用 状态压缩 算法将它压缩成二进制数 (0101)_2.一顿操作之后，我们的方程就变为：   看上去比之前像话多了. 将一组状态压缩成一个二进制数，塞进 f[ \ ] 的中括号里，再进行递推，这就是「状压 DP」. 问题 ¶在 n×n 的棋盘上放 m 个国王，国王可攻击相邻的 8 个格子.求使他们无法互相攻击的方案总数. 预处理 ¶按照状压 DP 的套路，这道题大抵需要我们用二进制数表示某一行的状态.   为了后续的需要，我们需要进行预处理：   筛选出所有符合题目条件的状态.   保存每种合法状态对应的国王个数.   由于每行有 n 个格子，因此表示状态的二进制数最大为 2^n-1. 原理 ¶f[i][s][k]：棋盘的前 i 行已经摆好，第 i 行摆的状态是 s，并且一共摆了 k 个国王时有几种合法的方案. 
    </content>
  </item>
  

  
  <item>
    <title>状态压缩</title>
    <link>/post/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/</link>
    
    <summary>将长为 $m$ 的 bool 数组用 $m$ 位二进制数表示，其中 $i$ 位等于原数组第 $i$ 个元素.</summary>
    
    <content>
      简介 ¶将长为 m 的 bool 数组用 m 位二进制数表示，其中 i 位等于原数组第 i 个元素. 此方法能极大节省空间. 二进制数的相关操作方法：    操作 运算     取出第 k 位数 (n &amp;gt;&amp;gt; (k - 1)) &amp;amp; 1   将第 k 位取反 n ^= (1 &amp;lt;&amp;lt; (k - 1))   将第 k 位赋值为 1 n |= (1 &amp;lt;&amp;lt; (k - 1))   将第 k 位赋值为 0 n &amp;amp;= ~ (1 &amp;lt;&amp;lt; (k - 1))    lowbit 运算 ¶lowbit(n) 为 n 在二进制下「最低位的 1 和其后所有的 0」构成的数. 例：n=(101000)_2，lowbit(n)=(1000)_2. n_i：n 在二进制下的第 i 位数字.  设 n_k=1，n_0\cdots n_{k-1}=0.  将 n 的每一位取反，此时 n_k=0，n_0\cdots n_{k-1}=1，其余位和原来相反. 再令 n=n&#43;1，此时 n_k=1，n_0\cdots n_{k-1}=0，其余位仍和原来相反. 因此 n\&amp;amp;(\sim n&#43;1) 仅有第 k 位为 1.  由于在补码表示下 -n=\sim n&#43;1，故  
    </content>
  </item>
  

  
  <item>
    <title>区间 DP</title>
    <link>/post/acm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4-dp/</link>
    
    <summary>区间 DP 以区间为研究对象.</summary>
    
    <content>
      简介 ¶区间 DP 以区间为研究对象. 通常设 f[l,r] 为区间 [l,r] 的值，用 f[ 小区间 ] 的值推出 f[ 大区间 ] 的值. 问题 ¶n 堆石子排成一列，第 i 堆石子重量为 A_i. 每次合并相邻两堆石子，消耗的体力值为其重量和. 求将所有石子合并为一堆，最少消耗多少体力. 原理 ¶f[l,r]：合并第 l 堆至第 r 堆石子的最少体力值. 合并第 l\sim r 堆石子可分为三步（设 k 为 [l, r) 中的某个数）：   合并第 l\sim k 堆石子，消耗体力值 f[l,k].   合并第 k&#43;1\sim r 堆石子，消耗体力值为f[k&#43;1,r].   合并剩下两堆石子，消耗体力值 \displaystyle\sum_{i=l}^r A_i.   枚举 k，找出最小的体力值. 其中 \displaystyle\sum_{i=l}^r A_i 可以用 前缀和 优化. 计算顺序为 f[ 小区间 ]\rightarrow f[ 大区间 ]，故枚举区间长度的循环在最外层. 时间复杂度为 O(n^3) 
    </content>
  </item>
  

  
  <item>
    <title>记忆化搜索</title>
    <link>/post/acm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</link>
    
    <summary>求 Fibonacci 第 $i$ 项的深搜程序如下：</summary>
    
    <content>
      求 Fibonacci 第 i 项的深搜程序如下： 该程序直观，但运行效率低. 以 f(7) 为例，列出函数调用情况：  随着 n 的增大，f(n) 的时间复杂度呈指数级增长. 我们发现，有很多函数被重复调用. 使用「记忆化搜索」可避免此情况. 建立数组 F 保存计算结果.  若 f(x) 未被调用过，算出 f(x) 的值，并存入 F[ x] 若 f(x) 已被调用过，直接返回 F[ x]   记忆化搜索的时间复杂度与动态规划相当，但效率略低. 若动态规划难以设计，则可以采用该算法. 
    </content>
  </item>
  

  
  <item>
    <title>高精度</title>
    <link>/post/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/</link>
    
    <summary>高精度是支持高位数的运算系统.</summary>
    
    <content>
      简介 ¶高精度是支持高位数的运算系统. 本章仅介绍最常用的正整数运算系统. 构造 ¶在 vector&amp;lt;int&amp;gt; 容器内保存每位数字，并实现自动处理进位. 注意：vector&amp;lt;int&amp;gt; 的位数要从 0 记起（第 0 位，第 1 位，\cdots）. 输入 ¶取出字符串的每一位，倒序存入数组. 输出 ¶数据是倒序储存的，故倒序输出. 比较 ¶先比较位数. 若位数相同，则从高位到低位逐位比较. 加法 ¶从低位到高位，将两数对应位置相加. 先实现 &#43;= 方法，更简洁高效. 减法 ¶返回差的绝对值. 从低位到高位，将两数对应位置相减. 不够减要借位. 乘法 ¶将 a 的第 i 位乘 b 的第 j 位累加在答案的第 i&#43;j 位上. 除法 ¶先实现带余除法函数，再重载符号方法. 将 b 和 a 最高位对齐，重复相减，统计减的次数. 
    </content>
  </item>
  

  
  <item>
    <title>背包问题</title>
    <link>/post/acm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85-dp/</link>
    
    <summary>给定若干物品的体积和价值，将其装入固定容积的背包，以使总价值尽可能大.</summary>
    
    <content>
      01 背包 ¶ 给定 n 个物品，第 i 个物品体积为 c[i], 价值为 w[i]. 现有容积为 m 的背包，求将物品装入背包得到的最大价值.  f[i,v]: 从前 i 个物品中，选出总体积为 v 的物品，能得到的最大价值.  不选第 i 个物品：f[i,v]=f[i-1,v]. 选第 i 个物品：f[i,v]=f[i-1,v-w_i]&#43;c_i.  时间复杂度：O(nm). 空间优化 ¶实际上，状态转移方程 的第一维可以去掉，即让新状态覆盖旧状态，以降低空间开销. 但在程序中，直接移除第一维会导致错误. 令 w=1,c=2，执行内层循环，可见错误的根源.         v=1           v 0 1 2 3 4     f[v] \textcolor{blue}{0} \textcolor{blue}{f[v-w]}&#43;c=2 0 0 0          v=2           v 0 1 2 3 4     f[v] 0 \textcolor{blue}{2} \textcolor{blue}{f[v-w]}&#43;c=4 0 0          v=3           v 0 1 2 3 4     f[v] 0 2 \textcolor{blue}{4} \textcolor{blue}{f[v-w]}&#43;c=6 0          v=4           v 0 1 2 3 4     f[v] 0 2 4 \textcolor{blue}{6} \textcolor{blue}{f[v-w]}&#43;c=8         在内层循环中，f[v-w] 不能比 f[v] 先更新，否则相当于同一物品被装多次. 倒序枚举 v 以解决问题.         v=4           v 0 1 2 3 4     f[v] 0 0 0 \textcolor{blue}{0} \textcolor{blue}{f[v-w]}&#43;c=2          v=3           v 0 1 2 3 4     f[v] 0 0 \textcolor{blue}{0} \textcolor{blue}{f[v-w]}&#43;c=2 2          v=2           v 0 1 2 3 4     f[v] 0 \textcolor{blue}{0} \textcolor{blue}{f[v-w]}&#43;c=2 2 2          v=1           v 0 1 2 3 4     f[v] \textcolor{blue}{0} \textcolor{blue}{f[v-w]}&#43;c=2 2 2 2         完全背包 ¶ 基于 01 背包，每种物品可装无限次.  f[i,v]: 从前 i 种物品中，选出总体积为 v 的物品，能得到的最大价值.  不选第 i 种物品：f[i,v]=f[i-1,v]. 多选一个第 i 种物品：f[i,v]=f[i,v-w_i]&#43;c_i.  时间复杂度：O(nm). 空间优化 ¶参照 01 背包 - 空间优化 中的错误做法：直接移除第一维，并升序枚举 v，相当于将同种物品装多次.         v=1           v 0 1 2 3 4     f[v] \textcolor{blue}{0} \textcolor{blue}{f[v-w]}&#43;c=2 0 0 0          v=2           v 0 1 2 3 4     f[v] 0 \textcolor{blue}{2} \textcolor{blue}{f[v-w]}&#43;c=4 0 0          v=3           v 0 1 2 3 4     f[v] 0 2 \textcolor{blue}{4} \textcolor{blue}{f[v-w]}&#43;c=6 0          v=4           v 0 1 2 3 4     f[v] 0 2 4 \textcolor{blue}{6} \textcolor{blue}{f[v-w]}&#43;c=8         多重背包 ¶ 基于 01 背包，第 i 种物品可装 s_i 次.  在内层循环中，分别绑定 1,2,\cdots s_i 个物品作为一个物品，参与 01 背包. 时间复杂度：O(m\sum s_i). 二进制优化 ¶ 任意正整数 n 可拆分为 1,2,4,\cdots,2^k,n-2^k（n-2^k≥0 且 k 尽量大）. 相反，1,2,4,\cdots,2^k,n-2^k 能且仅能组合出 [1,n] 中的所有整数.  将 s_i 个物品拆分为 1,2,4,\cdots,2^k,s_i-2^k 个物品（共 \log s_i 组），并绑定每组为一个物品，参与 01 背包. 例如，s_i=15 可以拆分为以下 4 组：    组别 1 2 3 4     总体积 w_i 2w_i 4w_i 8w_i   总价值 c_i 2c_i 4c_i 8c_i    此 4 组物品可组合出所有策略（选 1\cdots 15 个物品）. 例如要选 12 个物品，则同时选第 3,4 组即可. 时间复杂度：O(m\sum\log{s_i}). 分组背包 ¶ 背包体积为 m，有 t 组物品，第 k 组有 s_k 个，其中第 i 个体积为 w_{ki}，价值为 c_{ki}. 每组只能取走一个物品. 求将物品装入背包得到的最大价值.  f[k,v]：从前 k 组物品中，选出总体积为 v 的物品，能得到的最大价值.  不选第 k 组：f[k,v]=f[k-1,v]. 选第 k 组：\su f[k,v]=\max_{1\leq i\leq s_k}\ f[k-1,v-w_{ki}]&#43;c_{ki}.  可以省去第一维. 时间复杂度：O(nm). 二维背包 ¶ 背包体积为 V，承重为 M. 有 n 个物品，第 i 个体积为 v_i，质量为 m_i，价值为 c_i. 求将物品装入背包得到的最大价值.  f[p,q]：用体积为 p，承重为 q 的背包放物品，能获得的最大总价值. 时间复杂度为 O(nVM). 方案总数 ¶ 基于 01 背包，求将物品放入背包的方案数.  g[i,v]：把前 i 个物品（部分或全部）放入体积为 v 的背包的方案总数.  不放第 i 个物品：有 g[i-1,v] 种 放第 i 个物品：有 g[i-1,v-w_i] 种   同样可以省去第一维：  初始条件：g[0]=1. 因为当背包体积为 0 时只有一个方案：不放任何物品. 最优方案总数 ¶ 基于 01 背包，求最优方案数.  已知 01 背包 的状态转移方程： g[i,v]：把前 i 个物品（部分或全部）放入体积为 v 的背包的最优方案数.   若 f[i-1,v]&amp;gt;f[i-1,v-w_i]&#43;c_i，不放物品 i 最优：g[i,v]=g[i-1,v].   若 f[i-1,v]&amp;lt;f[i-1,v-w_i]&#43;c_i，放物品 i 最优：g[i,v]=g[i-1,v-w_i].   若相等，则两种方案都最优：g[i,v]=g[i-1,v]&#43;g[i-1,v-w_i].   省去第一维： 
    </content>
  </item>
  

  
  <item>
    <title>基础 DP</title>
    <link>/post/acm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%9F%BA%E7%A1%80-dp/</link>
    
    <summary>一些 DP 的经典问题.</summary>
    
    <content>
      斐波那契数列 ¶斐波那契数列是形如 \{1,1,2,3,5,8,\cdots\} 的数列. 求数列的第 n 项.     chevron_right分析   f[n]：数列的第 n 项.   汉诺塔问题 ¶汉诺塔由 n 个不同的盘子和 3 根杆子组成. 初始时，n 个盘子从小到大叠在 a 杆上：  现在，按以下规则将 n 个盘子从 a 杆移到 c 杆.  一次只能动一个盘子. 盘子只能放在杆上. 大盘子不能叠在小盘子上.  求移动盘子的最少次数.     chevron_right分析   f[n]：将 n 个盘子从一杆移至另一杆，所需的最少移动次数. 将 n 个盘子从 a 杆移到 c 杆，需要以下 3 步：  将 a 杆的 n-1 个盘子移至 b 杆（共 f[n-1] 次）. 将 a 杆的最后一个盘子移至 c 杆（共 1 次）. 将 b 杆的 n-1 个盘子移至 c 杆（共 f[n-1] 次）.    骨牌问题 ¶用若干 1×2 的骨牌铺满 2×n 的方格. 如图为 n=3 时的所有铺法：  求任意 n 对应的方法总数.     chevron_right分析   f[n]：n 对应的方法总数.  若第一个骨牌竖放在左边，则剩余 2×(n-1) 个空方格，铺法数为 f[n-1]. 若第一个骨牌横放在左上角，为了不留空，第二个骨牌必须横放在其正下方. 剩余 2×(n-2) 个空方格，铺法数为 f[n-2].  状态转移方程几乎和 斐波那契数列 一致.   平面分割问题 ¶平面上有 n 条闭曲线，每 2 条恰好交于 2 点，且每 3 条不交于同一点. 求平面被分割成的区域个数.     chevron_right分析   a[n]：n 条封闭曲线分割成的区域个数.  由上图可得： 即 正确性证明： 新增一条曲线时，每与一条已有曲线相交一次，就增加一个区域. 而新增的第 n 条曲线与已有的 n-1 条曲线各有 2 个交点 ∴ 新增区域数 = 新增交点数 =2\cdot (n-1). ∴ 现有区域个数 a[n]= 原有区域个数 &#43; 新增区域个数 =a[n-1]&#43;2(n-1).   最长上升子序列 (LIS) ¶求序列 A（长度 n）的最长上升子序列 \text{LIS}(A) 的长度. 例：A=\{2,3,6,4,5,1\}, \text{LIS}(A)=\{2,3,4,5\}（长度 4）.     chevron_right分析   f[i]：\text{LIS}(A_{1\cdots i}) 的长度. 枚举 j=1\cdots i-1：  若 A_j&amp;lt;A_i，则 A_i 可以接在 \text{LIS}(A_{1\cdots j}) 后面，形成的上升子序列长度为 f[j]&#43;1. 若 A_j≥A_i，A_j 对 f[i] 没有贡献，直接跳过.      chevron_right单调栈优化   扫描每一个数，将其加入单调栈. 假设当前单调栈内有 \{2,3,6\}，而扫描到 4. 根据贪心原理，将 6 替换为 4 必定更优. 当扫描到 a[i]：  若 a[i] 大于栈尾，则直接将其入栈. 否则在栈中二分查找第一个 \geq a[i] 的数，将其替换为 a[i].  最终栈的长度即为 LIS 的长度. 时间复杂度为 O(n\log{n}).      最长公共子序列 (LCS) ¶求序列 A（长度 n）和序列 b（长度 m）的最长公共子序列 \text{LCS}(A,B) 的长度. 例：A= freeze, B= refeze, \text{LCS}(A,B)= reeze（长度 5）.     chevron_right分析   f[i,j]：\text{LCS}(A_{1\cdots i},B_{1\cdots j}) 的长度. 枚举 i=1\cdots n： 枚举 j=1\cdots m：  若 A_i≠B_j，继承最优子状态：f[i,j]=\max(f[i-1,j],f[i,j-1]). 若 A_i=B_j，则 A_i（或 B_j）可以接在 \text{LCS}(A_{1\cdots i-1},B_{1\cdots j-1}) 之后，形成的公共序列长度为 f[i-1,j-1]&#43;1.    数字金字塔 ¶三角矩阵 A 有 n 行，第 i 行有 i 列. 从第一行第一列出发，每次可以移动到下一行相邻的两个数字. 到达底部时，经过的数字之和最大为多少？  此例中，最优路径为 13→8→26→15，最大值为 62.     chevron_right分析   (i,j)：第 i 行第 j 列的数字. f[i,j]：走到 (i,j) 时，经过的数字之和的最大值. 逆推法：要走到 (i,j)，则上一步只能在 (i-1,j-1) 或 (i-1,j). 注意：当 j=1 或 j=i 时，f[i-1,j-1] 和 f[i-1,j] 会越界. 故 f 数组须初始化为 -∞，以使越界的元素在 \max 操作中被自动淘汰.   数字矩阵 ¶有 n 行 m 列的数字矩阵 A. 从左上角出发，每次只能向下或向右走一步. 到右下角时，经过的数字之和最大为多少？  此例中，最优路径为 17→1→20→12→9→2，最大值为 61.     chevron_right分析   (i,j)：第 i 行第 j 列的数字. f[i,j]：走到 (i,j) 时，经过的数字之和的最大值. 逆推法：由于只能向左走或向下走，要走到 (i,j)，上一步只能在 (i-1,j) 或 (i,j-1). 注意：当 i=1 或 j=1 时，f[i-1,j] 和 f[i,j-1] 会越界. f 数组须初始化为 -∞.   前缀和 ¶前缀和是一种重要的预处理技巧，能大幅降低查询区间元素和的时间复杂度. 预处理 ¶数列 A 有 n 个元素. f[i]: A_1 到 A_i 的和.  时间复杂度：O(n). 查询 ¶g[i,j]：A_i 到 A_j 的和.  单次查询的时间复杂度：O(1). 二维前缀和 ¶预处理 ¶矩阵 A 有 n 行 m 列. f[i,j]：以 (1,1) 为左上角，以 (i, j) 为右下角的矩阵的元素和.   时间复杂度：O(nm). 查询 ¶g[x_1,y_1,x_2,y_2]：以 (x_1,y_1) 为左上角，以 (x_2, y_2) 为右下角的矩阵的元素和.   单次查询的时间复杂度：O(1). 差分 ¶差分是前缀和的逆运算，能大幅降低区间修改的时间复杂度. 预处理 ¶数列 A 有 n 个元素. 令 f[i]=A_i-A_{i-1}. f 为差分数列. 时间复杂度：O(n). 区间修改 ¶当给 A_l\cdots A_r 统一加上 x 时，f[l] 增加了 x，f[r&#43;1] 减少了 x, f 数列中其余元素不变. 因此可以每次只修改 f[l] 和 f[r&#43;1]，最后通过 f 数列还原出 A. 单次修改的时间复杂度：O(1). 
    </content>
  </item>
  

  
  <item>
    <title>动态规划（DP）</title>
    <link>/post/acm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    
    <summary>动态规划（DP）是打表的最高境界.</summary>
    
    <content>
      简介 ¶动态规划（DP）是打表的最高境界. 我们从一个案例入手 DP. 案例 ¶斐波那契数列形如 \{1,1,2,3,5,8,\cdots\}. 计算此数列的第 n 项 f[n]. 根据数列特征，列出递推公式 首先，将 f[1]=1,f[2]=1 填入表.    f[1] f[2]     1 1    计算 f[3]=f[2]&#43;f[1] 并填入表.    f[1] f[2] \color{red}{f[3]}     1 1 \color{red}{2}    计算 f[4]=f[3]&#43;f[2] 并填入表.    f[1] f[2] f[3] \color{red}{f[4]}     1 1 2 \color{red}{3}    重复计算填表的步骤，直到得到 f[n].    f[1] f[2] f[3] f[4] f[5] f[6] f[7] \cdots f[n]     1 1 2 3 5 8 13 \cdots     时间复杂度：O(n). 步骤 ¶ 为问题设计 状态. 列出 状态转移方程. 以正确的顺序解决各级问题.  术语 ¶状态 ¶状态是表格中所填数字的意义. 状态转移方程 ¶状态转移方程描述状态之间的关系. 斐波那契数列的状态转移方程为 
    </content>
  </item>
  

  
  <item>
    <title>搜索</title>
    <link>/post/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/</link>
    
    <summary>运用计算机的高性能枚举问题的答案.</summary>
    
    <content>
      简介 ¶搜索算法运用计算机的高性能枚举问题的所有可能答案，并逐一校验. 案例 ¶设集合 A 满足以下性质  若 x\in A，则 2x\in A. 若 x\in A，则 3x-1\in A.  若 3\in A，问 23\in A 是否成立？ A 的性质可抽象为下图：  以 3 为树根，向下拓展树形图. 这样，树中的所有节点都属于 A. 于是只需查找 23 是否在树中.  对于复杂的问题，可以先抽象出关系图，再用搜索算法求解. 广度优先搜索（BFS） ¶广度优先搜索（BFS）按层次搜索节点. 其原理如下：  建立空队列. 将根节点入队. 取出队头节点，将其所有子节点入队，重复直到队列为空.   BFS 搜索上图的步骤：  节点 1 入队 节点 1 出队，2,3 入队 节点 2 出队，4,5 入队 节点 3 出队，6,7 入队 节点 4 出队 节点 5 出队 节点 6 出队 节点 7 出队  注意：已进过队的节点不能再入队，否则可能导致死循环. 深度优先搜索 ¶深度优先搜索（Depth First Search，简称 DFS）尽可能往更深处搜索节点. 其原理为递归访问子节点.  DFS 搜索上图的步骤：  访问根节点 1.  访问子节点 2.  访问子节点 4. 访问子节点 5.   访问子节点 3.  访问子节点 6. 访问子节点 7.      注意：节点不能被重复访问，否则将导致死循环. 
    </content>
  </item>
  

  
  <item>
    <title>二分算法</title>
    <link>/post/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</link>
    
    <summary>通过若干次折半范围实现快速查询.</summary>
    
    <content>
      简介 ¶玩过「猜数字」游戏吗？  叫你的朋友在你背后写一个 [1,1000] 内的整数 n. 每轮你需要给出数字 x，你朋友只能回答「n 比 x 大」「n 比 x 小」或「n=x」.  你能求出猜中数字的最少次数吗？ 最初 n\in(0,1001). 你可以先猜 500.  若 n&amp;gt;500，则可以进一步确定 n\in(500,1001). 若 n&amp;lt;500，则可以进一步确定 n\in(0,500). 否则 n=500.  重复给出范围的中间数，每次都会将 n 的范围缩小一半，最多 \log_2{n} 次就可以确定 n 的值. 通过若干次折半范围实现快速查询，即为二分算法. 例 1 ¶求猜数字 n 需要的二分次数. 设 l 为 n 所在范围的左端点，r 为右端点，即 n\in(l,r). 重复执行以下操作：  取范围的中间数 \displaystyle m=\left\lfloor\frac{l&#43;r}{2}\right\rfloor. 若 n&amp;gt;m，则可以确定 n\in(m,r)，令 l=m. 若 n&amp;lt;m，则可以确定 n\in(l,m)，令 r=m. 若 n=m，跳出循环.  
    </content>
  </item>
  

  
  <item>
    <title>排序</title>
    <link>/post/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</link>
    
    <summary>重新排序数组 $a$（长度 $n$）中的元素.</summary>
    
    <content>
      简介 ¶重新排序数组 a（长度 n）中的元素. 本章只研究升序排序. 选择排序 ¶在第 i 次遍历中，交换 a[i] 和第 i 小的数. 时间复杂度：O(n^2). 冒泡排序 ¶重复扫描数组 a. 若 a[i]&amp;gt;a[i&#43;1] 就交换它们. 当没有可交换元素时结束排序. 时间复杂度：O(n^2). 插入排序 ¶将数组 a 分为 &amp;ldquo;已排序&amp;rdquo; 和 &amp;ldquo;未排序&amp;rdquo; 区. 每次将 &amp;ldquo;未排序&amp;rdquo; 区的一个元素插入 &amp;ldquo;已排序区&amp;rdquo; 的正确位置. 时间复杂度：O(n^2). 计数排序 ¶记录每个元素出现的次数，然后依次输出. f[x]：数字 x 出现了几次. 时间复杂度：O(n). 不适用于大范围元素. 快速排序 ¶ 设定基准数（通常是数组的中间数 &amp;mdash;- a[m]）. 扫描数组，将所有比 a[m] 小的元素移至其左，大于 a[m] 的元素移至其右. 对 a[m] 左右的子数组进行相同操作.  平均时间复杂度：O(n\log n). 最坏时间复杂度：O(n^2). 归并排序 ¶ 将数组分为左右两部分. 递归排序左右两数组. 合并两个已排序的子数组.  时间复杂度：O(n\log{n}).   
    </content>
  </item>
  

  
  <item>
    <title>递归</title>
    <link>/post/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/</link>
    
    <summary>函数调用自身的编程技巧是递归.</summary>
    
    <content>
      简介 ¶函数调用自身的编程技巧是递归. 递归的特点：  在函数中调用本身. 存在递归出口. 代码简洁但低效. 容易爆栈.  例 1 ¶计算阶乘 n!. f(n)=n! 可以定义为 以 f(3) 为例：  A：B，帮我算 f(3).  B：C，帮我算 f(2).  C：D，帮我算 f(1).  D：E，帮我算 f(0).  E：回 D, f(0)=1.   D：回 C, f(1)=f(0)\times 1=1.   C：回 B, f(2)=f(1)\times 2=2.   B：回 A, f(3)=f(2)\times 3=6.   A：f(3)=6.  例 2 ¶计算斐波那契数列的第 n 项. 
    </content>
  </item>
  

</rss>

